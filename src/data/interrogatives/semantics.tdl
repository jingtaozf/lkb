;;; CCB -- added the wh-value (with g-quant and param and wh-none as
;;;subtypes), and rel-values.

;;; JTB 07/19/01 What the hell are these for?  I'm thinking of
;;;ditching them since they don't get used anywhere.

;wh-value := *value*.
;wh-none := wh-value.

;rel-value := *value*.
;rel-none := rel-value.

;;; The basic semantic types are from Ginzburg and Sag chapter 3
;;;(January 2000 draft).

;;; <<< >>>> SOME BASIC SEMANTIC TYPES

sem-obj := feat-struc.

;;; CCB - 4/23/00 - removed RESTR from sem-obj, because it doesn't seem to come into play with any significance in the analysis.
;;;[ RESTR *list-of-facts* ].

;;;JTB - 7/16/01 - adding the REPRISABLE feature to prevent recursion
;;;on base case reprise rule and on direct-in-situ, as per discussions
;;;with Ivan.  For the record I'm not happy with this solution but ok.

;;;JTB 07/19/01 - Making semantics fit G&S Chapter 3.

message := sem-obj &
[REPRISABLE boolean].

austinian := message &
[ SOA soa,
  SIT sit ].

prop-constr := message &
[ PROP proposition ].

proposition := austinian & 
[ SOA r-soa ].

outcome := austinian & 
[ SOA i-soa ].

;;;JTB - 07/16/01 - REPRISABLE will default to true but false for
;;;reprises and direct in-situ.

fact := prop-constr.

question := prop-constr &
[ PARAMS *list-of-params*, 
  REPRISABLE /l true ].

illoc-rel := rel &
[ MSG-ARG message,
  ILLOCUTIONER index ].

assert-rel := illoc-rel &
[ MSG-ARG proposition ].

ask-rel := illoc-rel &
[ MSG-ARG question ].

order-rel := illoc-rel &
[ MSG-ARG outcome ].

exclaim-rel := illoc-rel &
[ MSG-ARG fact ].

unusual-rel := quant-rel.

;;; CCB - 5/17/00 - removed quants from the semantics to try to
;;;simplify things for the KB application.  Had to comment out the
;;;wh-exclamative-clause from constructions.tdl as a result, but I hadn't
;;;been playing with that much anyway.

;;;JTB - 07/19/01 - Put them back in, but I'm not going to touch them
;;;right now.  This is just to make the thing look like the book.
 
soa := sem-obj &
[ QUANTS *list-of-quants*,
  NUCL rel ].

r-soa := soa.

i-soa := soa &
[ T-PARAM param ].

pos-soa := soa.

qf-pos-soa := pos-soa &
[ QUANTS.LIST.FIRST pquant-rel  ].

qf-fr-pos-soa := pos-soa & 
[ QUANTS <! !> ].

neg-soa := soa &
[ QUANTS.LIST.FIRST nquant-rel ].

rel := sem-obj.

quant-rel := scope-obj & rel.

nquant-rel := quant-rel.

pquant-rel := quant-rel.

;;; <<< >>> MISC. SEMANTIC TYPES

mode-cat :< *value*.
   prop :< mode-cat.
   ques :< mode-cat.
   dir  :< mode-cat.
   ref  :< mode-cat.
   null-mode :< mode-cat.


null-sem := sem-obj.

scope-obj := sem-obj &
[ INDEX index,
  RESTR list-of-facts ].

; g-quant := scope-obj & wh-value.

param := scope-obj &
[ FOC boolean ].

;;;JTB 07/13/01 Added some param types to reduce redundant
;;;information, related to wh-words and their commonalities.

sit := feat-struc.

reln := feat-struc.

index := sem-obj &
[ PERNUM agr-cat ].

;;; <<< >>> LIST TYPES

list-of-scope-objs := *list*.

ne-list-of-scope-objs := list-of-scope-objs & ne-list &
[ FIRST scope-obj,
  REST list-of-scope-objs ].

e-list-of-scope-objs := list-of-scope-objs & e-list.

list-of-params := list-of-scope-objs.

ne-list-of-params := list-of-params & ne-list-of-scope-objs &
[ FIRST param,
  REST list-of-params ].

e-list-of-params := list-of-params & e-list-of-scope-objs.

list-of-quants := *list*.

ne-list-of-quants := list-of-quants & ne-list &
[ FIRST quant-rel,
  REST list-of-quants ].

e-list-of-quants := list-of-quants & e-list.

list-of-propositions := *list*.

ne-list-of-propositions := list-of-propositions & ne-list &
[ FIRST proposition,
  REST list-of-propositions ].

e-list-of-propositions := list-of-propositions & e-list.

list-of-relns := *list*.

ne-list-of-relns := list-of-relns & ne-list &
[ FIRST reln,
  REST list-of-relns ].

e-list-of-relns := list-of-relns & e-list.

list-of-facts := *list*.

ne-list-of-facts := list-of-facts & ne-list &
[ FIRST fact,
  REST list-of-facts ].

e-list-of-facts := list-of-facts & e-list.

;;; *diff-list* types.

;;;JTB 07/17/01 Experimenting with diff lists by removing the token
;;;identity condition.  This may help with stitching.

*list-of-params* := *diff-list* &
[ LIST list-of-params,
  LAST list-of-params ].

*e-list-of-params* := *list-of-params* & *e-diff-list* &
[ LIST e-list-of-params ].

;*e-list-of-params* := *list-of-params* & *e-diff-list* &
;[ LIST #1 & e-list-of-params,
;  LAST #1 ].

*list-of-scope-objs* := *diff-list* &
[ LIST list-of-scope-objs,
  LAST list-of-scope-objs ].

*e-list-of-locals* := *list-of-locals* & *e-diff-list* & 
[ LIST e-list-of-locals ].

*e-list-of-scope-objs* := *list-of-scope-objs* & *e-diff-list* & 
[ LIST e-list-of-scope-objs ].

;*e-list-of-locals* := *list-of-locals* & *e-diff-list* & 
;[ LIST #1 & e-list-of-locals,
;  LAST #1 ].

;*e-list-of-scope-objs* := *list-of-scope-objs* & *e-diff-list* & 
;[ LIST #1 & e-list-of-scope-objs,
;  LAST #1 ].

*list-of-quants* := *diff-list* &
[ LIST list-of-quants,
  LAST list-of-quants ].



*list-of-propositions* := *diff-list* &
[ LIST list-of-propositions,
  LAST list-of-propositions ].


*list-of-relns* := *diff-list* &
[ LIST list-of-relns,
  LAST list-of-relns ].

*list-of-facts* := *diff-list* &
[ LIST list-of-facts,
  LAST list-of-facts ].













