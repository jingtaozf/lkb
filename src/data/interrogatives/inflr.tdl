%(letter-set (!c bdfglmnprstz))
%(letter-set (!s abcdefghijklmnopqrtuvwxyz))
%(letter-set (!t bcdfghjklmnpqrstvwxz))
%(letter-set (!v aeiou))


const-lxm_infl_rule := inflected-lexeme &
[ ORTH #orth,
  DTRS < const-lxm & [ ORTH #orth,
                       NEEDS-AFFIX false ] > ].


sing-noun_infl_rule := inflected-lexeme &
[ ORTH #orth,
  DTRS < n-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,
                   SS.LOC.CAT [ HEAD noun & [ AGR.PERNUM 3sg ] ] ] > ].

plur-common-noun_infl_rule :=
%suffix (!s !ss) (!ss !ssses) (ss sses) (!ty !ties) (ch ches) (sh shes) (x xes) (z zes)
inflected-lexeme &
[ DTRS < n-lxm & [ NEEDS-AFFIX true,
                   SS.LOC.CAT [ HEAD noun & [ AGR.PERNUM 3pl ] ] ] > ].

;;; <<< >>> ENGLISH VERBAL INFLECTION

;;; CCB - The content for the verbs should also contain temporal information.  The handout that Ivan made for HPSG class says:

;  CONT r-soa & [ NUCL [ LOCN [ INDEX #1,
;                               RESTR <! t-overlap(#1, NOW) !>]


3rd-sing-verb_infl_rule := 
%suffix (!s !ss) (!ss !ssses) (ss sses) (!ty !ties) (ch ches) (sh shes) (x xes) (z zes) 
inflected-lexeme &
[ DTRS < v-lxm & [ NEEDS-AFFIX true,
                   SS.LOC [ CAT [ HEAD verb & [ FORM fin,
		                                PRED false ],
                                  SUBJ < [ LOC.CAT.HEAD [ AGR.PERNUM 3sg,
                                                           CASE nom ] ] > ],
                            CONT r-soa ] ] > ].



non-3rd-sing-verb_infl_rule := 
inflected-lexeme &
[ ORTH #orth,
  DTRS < v-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,
                   SS.LOC [ CAT [ HEAD verb & [ FORM fin,
		                                PRED false ],
                                  SUBJ < [ LOC.CAT.HEAD [ AGR.PERNUM non-3sg,
                                                           CASE nom ] ] > ],
                            CONT r-soa ] ] > ].



;;; CCB - getting a subjective parse for "I wonder who Sandy loved?" so turned it off for Ivan's demo.
;;; CCB - re-adding it for "I insist that Sandy leave". 


;;; CCB - shoud the subjuncitve be PRED true or false?
subjunctive+imperitive-verb_infl_rule := 
inflected-lexeme &
[ ORTH #orth,
  DTRS < v-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,               
                   SS.LOC [ CAT [ HEAD verb & [ FORM fin,
                                                IC false,
		                                PRED false ],
                                  SUBJ < [ LOC.CAT.HEAD.CASE nom ] > ],
                            CONT i-soa ] ] > ].



past-verb_infl_rule := 
%suffix (* ed) (!ty !tied) (e ed) (!t!v!c !t!v!c!ced) 
inflected-lexeme &
[ DTRS < v-lxm & [ NEEDS-AFFIX true,
                   SS.LOC [ CAT [ HEAD verb & [ FORM fin,
		                                PRED false ],
                                  SUBJ < [ LOC.CAT.HEAD.CASE nom ] > ],
                            CONT r-soa ] ] > ].


present-participle-verb_infl_rule := 
%suffix (!t!v!c !t!v!c!cing) (* ing) (e ing) (ee eeing) (ie ying)
inflected-lexeme &
[ DTRS < v-lxm & [ NEEDS-AFFIX true,
                   SS [ LOC.CAT.HEAD verb & [ FORM prp,
                                              PRED true ] ] ] > ].



perfect-participle-verb_infl_rule := 
%suffix (* ed) (!ty !tied) (e ed) (!t!v!c !t!v!c!ced) 
inflected-lexeme &
[ DTRS < v-lxm & [ NEEDS-AFFIX true,
                   SS [ LOC.CAT.HEAD verb & [ FORM pfp,
                                              PRED false ] ] ] > ].



inf-verb_infl_rule :=
inflected-lexeme &
[ ORTH #orth,
  DTRS < v-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,
                   SS [ LOC.CAT.HEAD verb & [ FORM inf,
		                              PRED false ] ] ] > ].
 

base-verb_infl_rule :=
inflected-lexeme &
[ ORTH #orth,
  DTRS < v-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,
                   SS [ LOC.CAT.HEAD verb & [ FORM base,
                                              PRED false ] ] ] > ].


;;; CCB - when the semantics for negation is added, the rule should actually be two rules, one for wide scope negation, the other for narrow.

;;; CCB - I'm futzing this a bit.  When I added the list of noncanonical synsems onto the SUBJ of the type clause, the canon-ss that I had assigned to the negation broke because of the list stitching.  Now I'm saying that neg-ss is a subtype of noncanon-ss.  A total hack.

negation-lexical-rule :=
inflected-lexeme &
[ ORTH #orth,
  SS.LOC.CAT [ HEAD [ AUX true,
                      NEG true,
                      INV false ],
               SPR < >,
               SUBJ < #1 >,
               COMPS < neg-ss & #neg & [ LOC.CAT.HEAD.FORM f_not ], #2 > ],
  ARG-ST < #1, #neg, #2 >, 
  DTRS < inflected-lexeme & [ NEEDS-AFFIX false,
                              ORTH #orth,
                              SS.LOC.CAT [ HEAD [ AUX true,
                                                  NEG false ],
                                           SPR < >,
                                           SUBJ < #1 >,
                                           COMPS < #2 > ], 
                              ARG-ST < #1, #2 > ] > ].
  



negation-lexical-rule-2 :=
inflected-lexeme &
[ ORTH #orth,
  SS.LOC.CAT [ HEAD [ AUX true,
                      NEG true,
                      INV false ],
               SPR < >,
               SUBJ < #1 >,
               COMPS < #neg & neg-ss & [ LOC.CAT.HEAD.FORM f_not ], #2, #3 > ],
  ARG-ST < #1, #neg, #2, #3 >,
  DTRS < inflected-lexeme & [ NEEDS-AFFIX false,
                      ORTH #orth,
                      SS.LOC.CAT [ HEAD [ AUX true,
                                          NEG false ],
                                   SPR < >,
                                   SUBJ < #1 >,
                                   COMPS < #2, #3 > ],
                      ARG-ST < #1, #2, #3 > ] > ].


;;; <<< >>> Argument Realization Principle

 
ARP-no-args := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < >,
               SUBJ < >,
               COMPS < > ],
  ARG-ST < >,
  DTRS < inflected-lexeme > ].


ARP-comps-only := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < >,
               SUBJ < >,
               COMPS #comps & ne-list ],
  ARG-ST #comps & [ REST list-of-synsems-wh-none ],
  DTRS < inflected-lexeme > ].


ARP-spr+comps := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < #spr >,
               SUBJ < >,
               COMPS #comps ],
  ARG-ST [ FIRST #spr,
           REST  list-of-synsems-wh-none & #comps ],
  DTRS < inflected-lexeme > ].



ARP-subj+comps := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < >,
               SUBJ < #subj >,
               COMPS #comps ],
  ARG-ST [ FIRST #subj,
           REST  list-of-synsems-wh-none & #comps ],
  DTRS < inflected-lexeme > ].




;;; <<< >>> STORE, SLASH, and WH Amalgamation Constraints

amalgamation-0 := inflected-lexeme+amalg &
[ SS [ SLASH <! !>,
       WH <! !>,
       LOC.STORE <! !> ],
  ARG-ST < >,
  DTRS < inflected-lexeme+ARP > ].

amalgamation-1 := inflected-lexeme+amalg &
[ SS [ SLASH #slash,
       WH #wh,
       LOC.STORE #store ],
  ARG-ST < [ SLASH #slash,
             WH #wh,
             LOC [ STORE #store ] ] >,
  DTRS < inflected-lexeme+ARP > ].


amalgamation-2 := inflected-lexeme+amalg &
[ SS.LOC.STORE [ LIST #store_1,
                 LAST #store_last ], 
 ARG-ST < [ LOC.STORE [ LIST #store_1,
                         LAST #store_2 ] ], [ LOC.STORE [ LIST #store_2,
                                                          LAST #store_last ] ] >,
 SS.SLASH [ LIST #slash_1,
            LAST #slash_last ], 
 ARG-ST < [ SLASH [ LIST #slash_1,
                    LAST #slash_2 ] ], [ SLASH [ LIST #slash_2,
                                                 LAST #slash_last ] ] >,
 SS.WH [ LIST #wh_1,
         LAST #wh_last ], 
 ARG-ST < [ WH [ LIST #wh_1,
                 LAST #wh_2 ] ], [ WH [ LIST #wh_2,
                                        LAST #wh_last ] ] >,
  DTRS < inflected-lexeme+ARP > ].


amalgamation-3 := inflected-lexeme+amalg &
[ SS.LOC.STORE [ LIST #store_1,
                 LAST #store_last ], 
  ARG-ST < [ LOC.STORE [ LIST #store_1,
                         LAST #store_2 ] ], [ LOC.STORE [ LIST #store_2,
                                                          LAST #store_3 ] ], [ LOC.STORE [ LIST #store_3,
                LAST #store_last ] ] >,
 SS.SLASH [ LIST #slash_1,
            LAST #slash_last ], 
 ARG-ST < [ SLASH [ LIST #slash_1,
                    LAST #slash_2 ] ], [ SLASH [ LIST #slash_2,
                                                 LAST #slash_3 ] ], [ SLASH [ LIST #slash_3,
                                                                              LAST #slash_last ] ] >,
 SS.WH [ LIST #wh_1,
         LAST #wh_last ], 
 ARG-ST < [ WH [ LIST #wh_1,
                 LAST #wh_2 ] ], [ WH [ LIST #wh_2,
                                        LAST #wh_3 ] ], [ WH [ LIST #wh_3,
                                                               LAST #wh_last ] ] >,
  DTRS < inflected-lexeme+ARP > ].
        

amalgamation-4 := inflected-lexeme+amalg &
[ SS.LOC.STORE [ LIST #store_1,
                 LAST #store_last ], 
  ARG-ST < [ LOC.STORE [ LIST #store_1,
                         LAST #store_2 ] ], [ LOC.STORE [ LIST #store_2,
                                                          LAST #store_3 ] ], [ LOC.STORE [ LIST #store_3, 
        LAST #store_4 ] ],  [ LOC.STORE [ LIST #store_4,
                                          LAST #store_last ] ]  >,
 SS.SLASH [ LIST #slash_1,
            LAST #slash_last ], 
 ARG-ST < [ SLASH [ LIST #slash_1,
                    LAST #slash_2 ] ], [ SLASH [ LIST #slash_2,
                                                 LAST #slash_3 ] ], [ SLASH [ LIST #slash_3,
           LAST #slash_4 ] ],  [ SLASH [ LIST #slash_4,
                                         LAST #slash_last ] ]  >,
 SS.WH [ LIST #wh_1,
         LAST #wh_last ], 
 ARG-ST < [ WH [ LIST #wh_1,
                         LAST #wh_2 ] ], [ WH [ LIST #wh_2,
                                                LAST #wh_3 ] ], 
    [ WH [ LIST #wh_3,
           LAST #wh_4 ] ],  [ WH [ LIST #wh_4,
                                       LAST #wh_last ] ]  >,
  DTRS < inflected-lexeme+ARP > ].
       




;;; <<< >>> GAP

canonical-comps := word &
[ SS [ LOC.CAT.COMPS #comps ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS #comps ] > ].

gap-1 := word &
[ SS [ LOC.CAT.COMPS < > ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS < gap-ss > ] > ].

gap-1-of-2 := word &
[ SS [ LOC.CAT.COMPS < #2 > ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS < gap-ss, #2 > ] > ].

gap-2 := word &
[ SS [ LOC.CAT.COMPS < #1 > ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS < #1, gap-ss > ] > ].

gap-both := word &
[ SS [ LOC.CAT.COMPS < > ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS < gap-ss, gap-ss > ] > ].

