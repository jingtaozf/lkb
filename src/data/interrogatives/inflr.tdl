%(letter-set (!c bdfglmnprstz))
%(letter-set (!s abcdefghijklmnopqrtuvwxyz))
%(letter-set (!t bcdfghjklmnpqrstvwxz))
%(letter-set (!v aeiou))

;const-lxm_infl_rule := inflected-lexeme & 
;[ ORTH #orth,
;  DTRS < const-lxm & [ ORTH #orth,
;                       NEEDS-AFFIX false ] > ].

;attrib-adj-lxm_infl_rule := inflected-lexeme & 
;[ ORTH #orth,
;  SS.LOC [ CAT [ HEAD [ PRED false,
;                        MOD < [ LOC [ CAT.HEAD noun,
;                                      CONT.INDEX #index ] ] > ],
;                 SUBJ < > ],
;           CONT.NUCL.ARG #index ],
;  DTRS < adj-lxm & [ SS.LOC.CAT.HEAD.PRED true,
;                     ORTH #orth,
;                     NEEDS-AFFIX false ] > ].

const-lxm_infl_rule := const-lxm_infl.
attrib-adj-lxm_infl_rule := attrib-adj-lxm_infl.
attrib-prep-lxm_infl_rule := attrib-prep-lxm_infl.

sing-noun_infl_rule := inflected-lexeme &
[ ORTH #orth,
  DTRS < n-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,
                   SS.LOC.CAT [ HEAD noun & [ AGR.PERNUM 3sg ] ] ] > ].

plur-common-noun_infl_rule :=
%suffix (!s !ss) (!ss !ssses) (ss sses) (!ty !ties) (ch ches) (sh shes) (x xes) (z zes)
inflected-lexeme &
[ DTRS < n-lxm & [ NEEDS-AFFIX true,
                   SS.LOC.CAT [ HEAD noun & [ AGR.PERNUM 3pl ] ] ] > ].

;;; <<< >>> ENGLISH VERBAL INFLECTION

;;; CCB - The content for the verbs should also contain temporal information.  The handout that Ivan made for HPSG class says:

;  CONT r-soa & [ NUCL [ LOCN [ INDEX #1,
;                               RESTR <! t-overlap(#1, NOW) !>]


3rd-sing-verb_infl_rule := 
%suffix (!s !ss) (!ss !ssses) (ss sses) (!ty !ties) (ch ches) (sh shes) (x xes) (z zes) 
inflected-lexeme &
[ DTRS < v-lxm & [ NEEDS-AFFIX true,
                   SS.LOC [ CAT [ HEAD verb & [ FORM fin,
		                                PRED false ],
                                  SUBJ < [ LOC.CAT.HEAD [ AGR.PERNUM 3sg,
                                                           CASE nom ] ] > ],
                            CONT r-soa ] ] > ].



non-3rd-sing-verb_infl_rule := 
inflected-lexeme &
[ ORTH #orth,
  DTRS < v-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,
                   SS.LOC [ CAT [ HEAD verb & [ FORM fin,
		                                PRED false ],
                                  SUBJ < [ LOC.CAT.HEAD [ AGR.PERNUM non-3sg,
                                                           CASE nom ] ] > ],
                            CONT r-soa ] ] > ].



;;; CCB - getting a subjective parse for "I wonder who Sandy loved?" so turned it off for Ivan's demo.
;;; CCB - re-adding it for "I insist that Sandy leave". 


;;; CCB - shoud the subjuncitve be PRED true or false?
subjunctive+imperitive-verb_infl_rule := 
inflected-lexeme &
[ ORTH #orth,
  DTRS < v-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,               
                   SS.LOC [ CAT [ HEAD verb & [ FORM fin,
                                                IC false,
		                                PRED false ],
                                  SUBJ < [ LOC.CAT.HEAD.CASE nom ] > ],
                            CONT i-soa ] ] > ].



past-verb_infl_rule := 
%suffix (* ed) (!ty !tied) (e ed) (!t!v!c !t!v!c!ced) 
inflected-lexeme &
[ DTRS < v-lxm & [ NEEDS-AFFIX true,
                   SS.LOC [ CAT [ HEAD verb & [ FORM fin,
		                                PRED false ],
                                  SUBJ < [ LOC.CAT.HEAD.CASE nom ] > ],
                            CONT r-soa ] ] > ].


present-participle-verb_infl_rule := 
%suffix (!t!v!c !t!v!c!cing) (* ing) (e ing) (ee eeing) (ie ying)
inflected-lexeme &
[ DTRS < v-lxm & [ NEEDS-AFFIX true,
                   SS [ LOC.CAT.HEAD verb & [ FORM prp,
                                              PRED true ] ] ] > ].



perfect-participle-verb_infl_rule := 
%suffix (* ed) (!ty !tied) (e ed) (!t!v!c !t!v!c!ced) 
inflected-lexeme &
[ DTRS < v-lxm & [ NEEDS-AFFIX true,
                   SS [ LOC.CAT.HEAD verb & [ FORM pfp,
                                              PRED false ] ] ] > ].



inf-verb_infl_rule :=
inflected-lexeme &
[ ORTH #orth,
  DTRS < v-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,
                   SS [ LOC.CAT.HEAD verb & [ FORM inf,
		                              PRED false ] ] ] > ].
 

base-verb_infl_rule :=
inflected-lexeme &
[ ORTH #orth,
  DTRS < v-lxm & [ NEEDS-AFFIX false,
                   ORTH #orth,
                   SS [ LOC.CAT.HEAD verb & [ FORM base,
                                              PRED false ] ] ] > ].


;;; CCB - when the semantics for negation is added, the rule should
;;;actually be two rules, one for wide scope negation, the other for
;;;narrow.

;;; CCB - I'm futzing this a bit.  When I added the list of
;;;noncanonical synsems onto the SUBJ of the type clause, the canon-ss
;;;that I had assigned to the negation broke because of the list
;;;stitching.  Now I'm saying that neg-ss is a subtype of noncanon-ss.  A
;;;total hack.

;;;JTB - 07/23/01 - This is missing some sort of restriction or
;;;another because I'm picking up "Kim is a dog" as a negation with
;;;"a" as the negation element.  Right now I'm goign to say that head
;;;of neg must be an adv.

;;;JTB - 07/29/01 - This is not working now because it's an
;;;inflected-lexeme and most AUX's have been moved beyond that lexically
;;;to account for their subject-raising effects by sais hack.

negation-lexical-rule :=
inflected-lexeme &
[ ORTH #orth,
  SS.LOC.CAT [ HEAD [ AUX true,
                      NEG true,
                      INV false ],
               SPR < >,
               SUBJ < #1 >,
               COMPS < neg-ss & #neg & [ LOC.CAT.HEAD adv & [FORM f_not ] ], 
                       #2 > ],
  ARG-ST < #1, #neg, #2 >, 
  DTRS < inflected-lexeme & [ NEEDS-AFFIX false,
                              ORTH #orth,
                              SS.LOC.CAT [ HEAD [ AUX true,
                                                  NEG false ],
                                           SPR < >,
                                           SUBJ < #1 >,
                                           COMPS < #2 > ], 
                              ARG-ST < #1, #2 > ] > ].

negation-lexical-rule-2 :=
inflected-lexeme &
[ ORTH #orth,
  SS.LOC.CAT [ HEAD [ AUX true,
                      NEG true,
                      INV false ],
               SPR < >,
               SUBJ < #1 >,
               COMPS < #neg & neg-ss & [ LOC.CAT.HEAD adv & [FORM f_not ] ], 
                       #2, #3 > ],
  ARG-ST < #1, #neg, #2, #3 >,
  DTRS < inflected-lexeme & [ NEEDS-AFFIX false,
                      ORTH #orth,
                      SS.LOC.CAT [ HEAD [ AUX true,
                                          NEG false ],
                                   SPR < >,
                                   SUBJ < #1 >,
                                   COMPS < #2, #3 > ],
                      ARG-ST < #1, #2, #3 > ] > ].


;;; <<< >>> Argument Realization Principle

;;; JTB 07/23/01 - Not one for SPR and SUBJ combinations?
;;;Hmmm... need to add some.
 
;;;Oh, I found the WHC... it's a constraint on these guys.  That
;;;actually sucks, since it's also here that I need to add some other
;;;stuff to make predicatively pumped lexemes not conform to this
;;;constraint, or that that pumping happens after the ARP.

ARP-no-args := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < >,
               SUBJ < >,
               COMPS < > ],
  ARG-ST < >,
  DTRS < inflected-lexeme > ].


ARP-comps-only := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < >,
               SUBJ < >,
               COMPS #comps & ne-list ],
  ARG-ST #comps & [ REST list-of-synsems-wh-none ],
  DTRS < inflected-lexeme > ].


ARP-spr+comps := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < #spr >,
               SUBJ < >,
               COMPS #comps ],
  ARG-ST [ FIRST #spr,
           REST  list-of-synsems-wh-none & #comps ],
  DTRS < inflected-lexeme > ].

;;;JTB 07/23/01 The intent of these changes is to incorporate some of
;;;the exceptions to predicatives that shows up.  Namely, if you're a
;;;non-predicative word you also follow the WHC.  If you're a
;;;predicative, your SPR may have whatever WH value it likes, the
;;;comps will all be WH empty and so will the SUBJ.

ARP-subj+comps := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < >,
               SUBJ < #subj >,
               COMPS #comps ],
  ARG-ST [ FIRST #subj,
           REST  list-of-synsems-wh-none & #comps ],
  DTRS < inflected-lexeme > ].

non-pred-ARP-subj+spr+comps := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < #spr >,
               SUBJ < #subj >,
               COMPS #comps,
               HEAD.PRED false ],
  ARG-ST [ FIRST #subj,
           REST [ FIRST #spr & [ WH <! !> ],
                  REST list-of-synsems-wh-none & #comps ] ],
  DTRS < inflected-lexeme > ].

pred-ARP-subj+spr+comps := inflected-lexeme+ARP &
[ SS.LOC.CAT [ SPR < #spr >,
               SUBJ < #subj >,
               COMPS #comps,
               HEAD.PRED true ],
  ARG-ST [ FIRST #subj,
           REST [ FIRST #spr,
                  REST list-of-synsems-wh-none & #comps ] ],
  DTRS < inflected-lexeme > ].

;ARP-subj+spr+comps := inflected-lexeme+ARP &
;[ SS.LOC.CAT [ SPR < #spr >,
;               SUBJ < #subj >,
;               COMPS #comps ],
;  ARG-ST [ FIRST #subj,
;           REST [ FIRST #spr & [ WH <! !> ],
;                  REST list-of-synsems-wh-none & #comps ] ],
;  DTRS < inflected-lexeme > ].

;;; <<< >>> Q-STORE, P-STORE, SLASH, and WH Amalgamation Constraints

amalg-0-lrule := inflected-lexeme+amalg-0 &
[ SS.LOC.CONT soa & [ QUANTS <! !> ],
  SS.LOC.Q-STORE <! !> ].

amalg-1-lrule := inflected-lexeme+amalg-1 &
[ SS.LOC.CONT soa & [QUANTS #quants],
  SS.LOC.Q-STORE <! !>,
  ARG-ST < [ LOC.Q-STORE #quants] > ].

amalg-2-lrule := inflected-lexeme+amalg-2 &
[ SS.LOC.CONT soa & [QUANTS [ LIST #quants1,
                              LAST #quants_last ] ],
  SS.LOC.Q-STORE <! !>,
  ARG-ST < [ LOC.Q-STORE [ LIST #quants1,
                           LAST #quants2 ] ], [ LOC.Q-STORE [ LIST #quants2,
                                                              LAST #quants_last ] ] > ].

amalg-3-lrule := inflected-lexeme+amalg-3 &
[ SS.LOC.CONT soa & [QUANTS [ LIST #quants1,
                              LAST #quants_last ] ],
  SS.LOC.Q-STORE <! !>,
  ARG-ST < [ LOC.Q-STORE [ LIST #quants1,
                           LAST #quants2 ] ], [ LOC.Q-STORE [ LIST #quants2,
                                                              LAST #quants3 ] ],  [ LOC.Q-STORE [ LIST #quants3, LAST #quants_last ] ] > ].

amalg-4-lrule := inflected-lexeme+amalg-4 &
[ SS.LOC.CONT soa & [QUANTS [ LIST #quants1,
                            LAST #quants_last ] ],
  SS.LOC.Q-STORE <! !>,
  ARG-ST < [ LOC.Q-STORE [ LIST #quants1,
                           LAST #quants2 ] ], [ LOC.Q-STORE [ LIST #quants2,
                                                              LAST #quants3 ] ],  [ LOC.Q-STORE [ LIST #quants3, LAST #quants4 ] ], [ LOC.Q-STORE [ LIST #quants4, LAST #quants_last ] ] > ].

;;;JTB 07/20/01 - Ok, the weird glomming on the Q-STORE is for
;;;determiners that introduce their own quatifiers and thus need to
;;;pass that up.  The other cases (like nouns and stuff) should have
;;;empty Q-STORES on the daughter and so this shouldn't cause any
;;;problems.

amalg-5-lrule := inflected-lexeme+amalg-1 &
[ SS.LOC.CONT scope-obj,
  SS.LOC.Q-STORE #quants,
  ARG-ST < [ LOC.Q-STORE #quants ] > ].

;amalg-5-2-lrule := inflected-lexeme+amalg-1 &
;[ SS.LOC.CONT scope-obj,
;  SS.LOC.Q-STORE [ LIST #quants1,
;                   LAST #quants_last ],
;  ARG-ST < [ LOC.Q-STORE [ LIST #quants1,
;                           LAST #quants2 ] ] >,
;  DTRS < [ SS.LOC.Q-STORE [ LIST #quants2,
;                            LAST #quants_last ] ] > ].

amalg-6-lrule := inflected-lexeme+amalg-2 &
[ SS.LOC.CONT scope-obj,
  SS.LOC.Q-STORE [ LIST #quants1,
                   LAST #quants_last ],
  ARG-ST < [ LOC.Q-STORE [ LIST #quants1,
                           LAST #quants2 ] ], [ LOC.Q-STORE [ LIST #quants2,
                                                              LAST #quants_last ] ] > ].

amalg-7-lrule := inflected-lexeme+amalg-3 &
[ SS.LOC.CONT scope-obj,
  SS.LOC.Q-STORE [ LIST #quants1,
                   LAST #quants_last ],
  ARG-ST < [ LOC.Q-STORE [ LIST #quants1,
                           LAST #quants2 ] ], [ LOC.Q-STORE [ LIST #quants2,
                                                              LAST #quants3 ] ],  [ LOC.Q-STORE [ LIST #quants3, LAST #quants_last ] ] > ].

amalg-8-lrule := inflected-lexeme+amalg-4 &
[ SS.LOC.CONT scope-obj,
  SS.LOC.Q-STORE [ LIST #quants1,
                   LAST #quants_last ],
  ARG-ST < [ LOC.Q-STORE [ LIST #quants1,
                           LAST #quants2 ] ], [ LOC.Q-STORE [ LIST #quants2,
                                                              LAST #quants3 ] ],  [ LOC.Q-STORE [ LIST #quants3, LAST #quants4 ] ], [ LOC.Q-STORE [ LIST #quants4, LAST #quants_last ] ] > ].

amalg-9-lrule := inflected-lexeme+amalg-0 &
[ SS.LOC.CONT scope-obj,
  SS.LOC.Q-STORE <! !> ].

;;; <<< >>> GAP

canonical-comps := word &
[ SS [ LOC.CAT.COMPS #comps ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS #comps ] > ].

gap-1 := word &
[ SS [ LOC.CAT.COMPS < > ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS < gap-ss > ] > ].

gap-1-of-2 := word &
[ SS [ LOC.CAT.COMPS < #2 > ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS < gap-ss, #2 > ] > ].

gap-2 := word &
[ SS [ LOC.CAT.COMPS < #1 > ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS < #1, gap-ss > ] > ].

gap-both := word &
[ SS [ LOC.CAT.COMPS < > ],
  DTRS < inflected-lexeme+amalg & [ SS.LOC.CAT.COMPS < gap-ss, gap-ss > ] > ].


