;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; GRAMMAR FOR ENGLISH INTERROGATIVE CONSTRUCTIONS
;;; by Chris Callison-Burch 
;;;
;;; based on Ch. 16 of Sag and Wasow (1999)
;;;
;;; lexeme-types.tdl
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; <<< >>> PART OF SPEECH

;;; VERB LEXEME DEFINITIONS 

v-lxm := lexeme & 
 [ SS [ LOC [ CAT [ HEAD verb & [ NEG false,
                                  ANA false],
                    SPR < >,
	            SUBJ < [ LOC.CAT phrase-cat & [ HEAD noun,
                                                     SPR < >,
                                                     COMPS < > ] ] > ] ],
        WH <! !> ] ].

; CCB -- temporarially removed content from verbs, because the pol-int-cl was breaking because of a failure to unify between soa and question.  So "Can Sandy sleep?"  Was breaking. 
;            CONT soa ] ].


non-auxv-lxm:= v-lxm &
[ SS.LOC [ CAT [ HEAD verb & [ INV false, 
                               AUX false ] ] ] ].

;;; CCB - Ivan says should only be LOC that are identified in the SUBJs
;auxv-lxm := v-lxm & 
;[ SS.LOC.CAT [ SUBJ < #2 >,
;               ARG-ST < #2 & [ LOC #1 &
;                                      [STORE <! > ] ], [ LOC.CAT [ SUBJ < [ LOC #1 & [ STORE <! > ] ] >, 
;                                                                    COMPS < > ] ] >

#|
auxv-lxm := v-lxm & 
<[ SS.LOC.CAT [ SUBJ < [ LOC /l #1 ] >,
               ARG-ST < [ LOC /l #1 ], [ LOC.CAT [ SUBJ < [ LOC /l #1  & [ STORE <! !> ] ] >, 
                                         COMPS < > ] ] > ] ].
|#

;;;JTB 07/14/01 - stopped coidentifying SUBJs and starting doing the
;;;locals fo the SUBJS, and insist that SLASH of complement be empty.

auxv-lxm := v-lxm & 
[ SS.LOC.CAT [ SUBJ < #2 >,
               ARG-ST < #2 & [LOC.CAT #1], [ LOC.CAT [ SUBJ < [ LOC.CAT #1, 
								LOC.STORE <! !>, 
         					                SLASH <! !>] >, 
                                              COMPS < > ] ] > ] ].

;;;JTB 07/014/01 - original definition but without #1 & STORE <! !> in COMP
;auxv-lxm := v-lxm & 
;[ SS.LOC.CAT [ SUBJ < #1 >,
;               ARG-ST < #1, [ LOC.CAT [ SUBJ < #1  >, 
;                                        COMPS < > ] ] > ] ].

dummy-auxv-lxm :=  v-lxm & 
[ SS.LOC.CAT.ARG-ST < [ LOC.CAT.HEAD [ AGR expl-index & [ PERNUM 1or3sg ] ] ],
                       #1 & [ LOC.CAT  phrase-cat & [ HEAD noun,
                                                      SPR < > ] ],
                       [ LOC.CAT [ HEAD [ PRED true ],
                                          SUBJ < #1 >,
                                          COMPS < > ] ] > ].
;s-rais.


;;; NOUN LEXEME DEFINITIONS 

n-lxm := lexeme &
 [ SS.LOC [ CAT [ HEAD noun & [ FORM /l normal, 
	        	        ANA /l false,
                                AGR /l ref-index,
                                MOD /l < > ],
                  SUBJ < >,
                  SPR /l < >,
                  COMPS /l < > ] ] ].

;            CONT param ] ].
	 
pron-lxm := n-lxm & no-args &
 [ SS [ LOC [ CAT [ HEAD noun & [ FORM /l normal, 
                                  ANA /l false ] ] ],
        WH <! !> ] ].

;;;JTB 07/17/01 - According to GS Chapter 5, the SPR.WH value and the
;;;WH value of this lexeme should be unified.  This isn't captured
;;;here, although that should be the ultimate effect since the COMPS
;;;for n-lxms is empty and so any stitching will accomplish the same
;;;thing.  Is this good enough?

cn-lxm := n-lxm &
 [ SS.LOC [ CAT [ HEAD [ AGR.PERNUM #agr ],
	          SPR < [ LOC.CAT phrase-cat & [ HEAD det & [ AGR.PERNUM #agr,
                                                               COUNT /l true ],
                                                  SPR < > ] ] > ] ] ].


pn-lxm := n-lxm & no-args &
 [ SS [ LOC [ CAT [ HEAD [ AGR.PERNUM 3sg ] ] ],
              WH <! !> ] ].

;;; NON-INFLECTING (CONST-LXM) LEXEME TYPES

const-lxm := lexeme.

det-lxm := const-lxm &
 [ SS [ LOC [ CAT [ HEAD det,
                    SUBJ < >,
                    SPR /l < >,
                    COMPS < > ],
              CONT null-sem ] ] ].


p-lxm := const-lxm &
 [ SS.LOC.CAT [ HEAD prep,
                    SPR < >,
                    COMPS < [ LOC [ CAT phrase-cat & [ HEAD noun,
                                                        SPR < >,
                                                       COMPS  < > ] ] ] > ] ].

;;;JTB 07/10/01 marking one shouldn't have a subject, predicative one should.
mkp-lxm := p-lxm &
 [ SS.LOC.CAT [ HEAD.PRED false,
                SUBJ < > ] ].

pdp-lxm := p-lxm &
 [ SS.LOC.CAT [ HEAD.PRED true,
                SUBJ < synsem > ] ].


comp-lxm := const-lxm &
 [ SS [ LOC.CAT [ HEAD comp,
                  SUBJ < >, 
                  SPR < > ],
        WH <! !> ] ].


;;; CCB - this is just a quick definiton.  Needs to be fixed.
adj-lxm := const-lxm &
 [ SS.LOC.CAT [ HEAD adj & [ FORM normal,
                             PRED true,
                             MOD < [ LOC.CAT.HEAD noun ] > ],
                SUBJ /l < >,
                SPR /l < >,
                COMPS /l < > ] ].

;;; CCB - this is just a quick definiton.  Needs to be fixed.
adv-lxm := const-lxm &
 [ SS.LOC.CAT [ HEAD adv,
                SUBJ < >,
                SPR < >,
                COMPS < > ] ].



;;; <<< >>> ARGUMENT SELECTION


; no-arguments (no-args)
no-args := lexeme &
[ SS.LOC.CAT.ARG-ST < > ].

; intransitive (intr)
intr := lexeme &
[ SS.LOC.CAT.ARG-ST < synsem, ... > ].

; strict-intransitive (str-intr)
str-intr := intr &
[ SS.LOC.CAT.ARG-ST < synsem > ].

; intransitive-xcomp (intr-xcomp)
intr-xcomp := intr &
[ SS.LOC.CAT.ARG-ST < synsem, synsem > ].

; subject-control (s-con)
s-con := intr-xcomp &
[ SS.LOC.CAT.ARG-ST < [ LOC [ CONT [ INDEX #1 ] ] ], 

                       [ LOC.CAT [ SPR < [ LOC [ CONT [ INDEX #1 ] ] ] >,
                                   COMPS < > ] ] > ].


; transitive (tran)
tran := lexeme &
[ SS.LOC.CAT.ARG-ST < synsem, synsem, ... > ].

; strict-transitive (str-tr)
str-tr := tran &
[ SS.LOC.CAT.ARG-ST < synsem, synsem > ].

; transitive-xcomp (tran-xcomp)
tran-xcomp := tran &
[ SS.LOC.CAT.ARG-ST < synsem, synsem, synsem > ].





;;; <<< >>> Maximal Subtypes of PART-OF-SPEECH and ARG-SELECTION

; strict-intransitive-verb (siv)
siv := non-auxv-lxm & str-intr.

; subject-control-verb (scv)
scv := non-auxv-lxm & s-con.

; subject-raising-verb (srv)
srv := non-auxv-lxm & s-rais.







; PP-argument (prep-arg)
prep-arg := lexeme &
[ SS.LOC.CAT.ARG-ST < synsem, [ LOC.CAT phrase-cat & [ HEAD prep,
                                                       SPR < >,
                                                       COMPS < > ] ] > ].

; NP-transitive-argument (NP-trans-arg) - Added by CCB 9/9/99
NP-trans-arg := tran &
[ SS.LOC.CAT.ARG-ST < synsem, [ LOC.CAT phrase-cat & [ HEAD noun,
                                                     SPR < >,
                                                     COMPS < > ] ] > ].

; ditransitive-argument (ditrans-arg) - Added by CCB 9/9/99
ditrans-arg := lexeme &
[ SS.LOC.CAT.ARG-ST < synsem, synsem, synsem > ].

; dative-argument (dt-arg) - Added by CCB 9/9/99
dt-arg := ditrans-arg &
[ SS.LOC.CAT.ARG-ST < synsem, [ LOC.CAT phrase-cat & [ HEAD noun,
                                                       SPR < >,
                                                       COMPS < > ] ], 
                              [ LOC.CAT phrase-cat & [ HEAD noun,
                                                       SPR < >,
                                                       COMPS < > ] ] > ].

; PP-ditransitive (ptv-arg) - Added by CCB 9/9/99
ptv-arg :=  ditrans-arg &
[ SS.LOC.CAT.ARG-ST < synsem, [ LOC.CAT phrase-cat & [ HEAD noun,
                                                     SPR < > ] ],
                              [ LOC.CAT phrase-cat & [ HEAD prep,
                                                       SPR < > ] ] > ].

; subject-raising (s-rais)
s-rais := lexeme &
[ SS.LOC.CAT.ARG-ST < #1, [ LOC.CAT [ SUBJ < #1 >,
                                       COMPS < > ] ] > ].







; PP-intransitive-verb (piv)
piv := non-auxv-lxm & prep-arg.

; strict-transitive-verb (stv)
stv := non-auxv-lxm & NP-trans-arg.


ctv := non-auxv-lxm & str-tr &
[ SS.LOC.CAT.ARG-ST < synsem, [ LOC [ CAT [ HEAD verbal & [ FORM fin ],
                                             SPR < >,
                                             COMPS < > ],
                                       CONT proposition ] ] > ].


; dative-verb (dtv)
dtv := non-auxv-lxm & dt-arg.

; PP-transitive-verb (ptv)
ptv := non-auxv-lxm & ptv-arg.





;;; <<>> Adjective Lexeme types.

; strict-intransitive-adjective (sia)
sia := adj-lxm & str-intr.

; PP-intransitive-adjective (pia)
pia := adj-lxm & prep-arg.

; strict-transitive-adjective (sta)
sta := adj-lxm & str-tr.

; subject-raising-adjective (sra)
sra := adj-lxm & s-rais.

; subject-control-adjective (sca)
sca := adj-lxm & s-con.

;;;JTB - 07/13/01 finding commonality in wh words.  All CAT features
;;;but HEAD are common, as well as SLASH, REL, DTRS.

wh-lxm:=inflected-lexeme+amalg &
[ SS [ LOC [ CAT [ SUBJ < >,
                   SPR < >,
                   COMPS < >,
                   ARG-ST < > ], 
	     CONT param],
       SLASH <! !>,
       REL <! !> ],       
  DTRS < inflected-lexeme > ].

wh-lxm-nexcl:=wh-lxm &
[ SS.LOC.CONT #1,
  SS.LOC.STORE <! #1 !> ].

wh-lxm-excl:=wh-lxm &
[ SS [LOC [CONT #1,
           STORE <! !> ],
      WH <! #1 !> ] ].

wh-n-lxm:=wh-lxm-nexcl &
[ SS.LOC.CAT.HEAD noun & [ FORM normal, 
	        	   ANA false,
                           AGR ref-index,
                           MOD < > ] ].

wh-det-lxm:=wh-lxm-nexcl &
[ SS.LOC.CAT.HEAD det ].

wh-lxm-foc:=wh-lxm-nexcl &
[ SS [LOC.CONT.FOC true,
      WH <! !> ] ].

wh-lxm-unfoc:=wh-lxm-nexcl &
[ SS [ LOC [ CONT #1 & [ FOC false ] ],
       WH <! #1 !> ] ].

wh-n-lxm-unfoc:=wh-n-lxm & wh-lxm-unfoc.
wh-n-lxm-foc:=wh-n-lxm & wh-lxm-foc.
wh-det-lxm-unfoc:=wh-det-lxm & wh-lxm-unfoc.
wh-det-lxm-foc:=wh-det-lxm & wh-lxm-foc.