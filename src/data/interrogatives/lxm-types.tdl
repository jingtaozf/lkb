;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; GRAMMAR FOR ENGLISH INTERROGATIVE CONSTRUCTIONS
;;; by Chris Callison-Burch 
;;;
;;; based on Ch. 16 of Sag and Wasow (1999)
;;;
;;; lexeme-types.tdl
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; <<< >>> PART OF SPEECH

;;; VERB LEXEME DEFINITIONS 

;;;JTB 07/18/01 - Trying to ditch all pumping rules.  Here eliminating
;;;phrase restrictions on COMPS and SUBJ and SPR of VPs.

;;;JTB 07/19/01 - Added default restriction on P-STORE to see if this
;;;prevents useless rule appliation.

;;;JTB 07/23/01 - These are a couple of hacks just to make the way
;;;Chris does copulas generalized.

;;;JTB 07/29/01 - This type is for things like "be" and "to" which are
;;;non-inflected and do subject raising (like auxiliaries) while
;;;inheriting soas.  It skims amalgamation and unifies the subject's
;;;cat and cont values and the cont.nucl value of the higher and lower
;;;verbs, and amalgamates everything else.  The difference between
;;;this and normal amalg is that it takes the quants list from the soa
;;;rather than the Q-STORE and amalgamates the subject onto that.

non-infl-vb-comp := inflected-lexeme+amalg &
[ SS [ LOC [ CONT [ NUCL /l #nucl,
                    QUANTS [ LIST #qlist1,
                             LAST #qlist_last ] ],
             CAT [ SUBJ < #subj & [ LOC.CAT.HEAD.PRED false ] >,
                   SPR < >,
                   COMPS < #comp > ],
             Q-STORE <! !>,
             P-STORE [ LIST #plist1, 
                       LAST #plist_last ] ],
       SLASH [ LIST #slash1, 
               LAST #slash_last ], 
       WH [ LIST #wh1, 
            LAST #wh_last ] ],
  ARG-ST < #subj & [ LOC [ CAT.HEAD.PRED false,
                           Q-STORE [ LIST #qlist1,
                                     LAST #qlist2 ],
                           P-STORE [ LIST #plist1, 
                                     LAST #plist2 ] ],
                     SLASH [ LIST #slash1, 
                             LAST #slash2 ],
                     WH [ LIST #wh1, 
                          LAST #wh2 ] ],
           #comp & [ LOC [ CONT [ NUCL /l #nucl,
                                  QUANTS [ LIST #qlist2,
                                           LAST #qlist_last ] ],
                           P-STORE [ LIST #plist2, 
                                     LAST #plist_last ] ],
                     SLASH [ LIST #slash2, 
                             LAST #slash_last ],
                     WH [ LIST #wh2, 
                          LAST #wh_last ] ] > ].

copula := non-infl-vb-comp &
[ SS.LOC.CAT.COMPS < [ LOC.CAT.HEAD.PRED true ] >,
  DTRS < auxv-lxm > ].

fin_copula := copula & 
[ SS.LOC.CAT.HEAD.FORM fin,
  SS.LOC.CONT r-soa,
  ARG-ST < [ LOC.CAT.HEAD.CASE nom ], synsem > ].

do-lexeme := non-infl-vb-comp &
[ SS.LOC.CAT [ HEAD verb & [ PRED false ],
               SUBJ < [ LOC.CAT.HEAD.CASE nom ] >,
               COMPS < [ LOC.CAT [ HEAD.FORM base,
                                   COMPS < > ] ] > ],
  DTRS < auxv-lxm > ].

do-lxm-unfoc := do-lexeme &
[ SS.LOC.CAT.HEAD [ AUX true,
                    FORM fin ] ].

do-lxm-foc := do-lexeme &
[ SS.LOC.CAT.HEAD.FORM fin ].

v-lxm := lexeme & 
 [ SS [ LOC [ CAT [ HEAD verb & [ NEG false,
                                  ANA false],
                    SPR < >,
	            SUBJ < [ LOC.CAT [ HEAD noun,
                                       SPR < >,
                                       COMPS < > ] ] > ],
              CONT soa,
              Q-STORE <! !> ],
        WH <! !> ] ].

non-auxv-lxm:= v-lxm &
[ SS.LOC [ CAT [ HEAD verb & [ INV false, 
                               AUX false ] ] ] ].

;;;JTB 07/14/01 - stopped coidentifying SUBJs and starting doing the
;;;locals fo the SUBJS, and insist that SLASH of complement be empty.

auxv-lxm := v-lxm & s-rais. 

;;;JTB 07/014/01 - original definition but without #1 & P-STORE <! !> in COMP
;auxv-lxm := v-lxm & 
;[ SS.LOC.CAT [ SUBJ < #1 >,
;               ARG-ST < #1, [ LOC.CAT [ SUBJ < #1  >, 
;                                        COMPS < > ] ] > ] ].

;;;JTB 07/18/01 - Trying to ditch all pumping rules.  Here eliminating
;;;phrase restrictions on COMPS and SUBJ and SPR of VPs.

dummy-auxv-lxm :=  v-lxm & 
[ ARG-ST < [ LOC.CAT.HEAD [ AGR expl-index & [ PERNUM 1or3sg ] ] ],
             #1 & [ LOC.CAT  [ HEAD noun,
                               SPR < > ] ],
                  [ LOC.CAT [ HEAD [ PRED true ],
                                     SUBJ < #1 >,
                                     COMPS < > ] ] > ].
;;; NOUN LEXEME DEFINITIONS 

;;;JTB 07/19/01 - Noun semantics is now a scope-obj.  The
;;;determiner/pumping rule/specific lexical entry will determine
;;;whether it's a quant or a param.

n-lxm := lexeme &
 [ SS.LOC [ CAT [ HEAD noun & [ FORM /l normal, 
	        	        ANA /l false,
                                AGR /l ref-index,
                                MOD /l < > ],
                  SUBJ /l < >,
                  SPR /l < >,
                  COMPS /l < > ],
            CONT scope-obj ] ].
	 
pron-lxm := n-lxm & no-args &
 [ SS [ LOC [ CAT [ HEAD noun & [ FORM /l normal, 
                                  ANA /l false ] ],
              Q-STORE <! !>,
              P-STORE <! !> ],
        WH <! !> ] ].

;;;JTB 07/17/01 - According to GS Chapter 5, the SPR.WH value and the
;;;WH value of this lexeme should be unified.  This isn't captured
;;;here, although that should be the ultimate effect since the COMPS
;;;for n-lxms is empty and so any stitching will accomplish the same
;;;thing.  Is this good enough?

;;;JTB 07/18/01 - Trying to ditch all pumping rules.  Here eliminating
;;;phrase restrictions on COMPS and SUBJ and SPR.

cn-lxm := n-lxm &
 [ SS.LOC.CAT [ HEAD.AGR.PERNUM #agr,
	        SPR < [ LOC [ CAT [ HEAD det & [ AGR.PERNUM #agr,
                                                 COUNT /l true ],
                                    SPR < > ] ] ] > ],
   SS.LOC.CONT [ INDEX #index, RESTR < [ PROP.SOA.NUCL.INSTANCE #index ] > ] ].

;;;JTB 07/29/01 - For nouns that take a prepositional complement like
;;;picture.

tr-cn-lxm := cn-lxm & str-tr & prep-arg.

pn-lxm := n-lxm &
 [ SS [ LOC [ CAT.HEAD [ PRED false, AGR.PERNUM 3sg ],
              CONT param,
              Q-STORE <! !>,
              P-STORE <! !> ],
        WH <! !>,
        SLASH <! !> ] ].

;;; NON-INFLECTING (CONST-LXM) LEXEME TYPES

const-lxm := lexeme.

det-lxm := inflected-lexeme+amalg &
[ SS [ LOC [ CAT [ HEAD det & [ SPEC /l scope-obj ],
                   SUBJ < >,
                   SPR /l < >,
                   COMPS < > ],
             CONT scope-obj ],
       SLASH <! !> ],
  DTRS < inflected-lexeme >,
  ARG-ST /l < > ].

non-wh-det-lxm := det-lxm &
[ SS [ LOC [ CAT [ HEAD.SPEC /l [ INDEX #index,
                                  RESTR #restr ] ],
             CONT #cont & /l [ INDEX #index,
                               RESTR #restr ],
             Q-STORE <! #cont !>,
             P-STORE <! !> ],
     WH <! !> ] ].

gen-poss-det-lxm := det-lxm &
[ SS [ LOC [ CAT [ HEAD.SPEC [ INDEX #index,
                               RESTR #restr1 ] ],
             CONT #cont,
             Q-STORE <! #cont & the-rel & [ INDEX #index,
                                            RESTR [ FIRST.PROP.SOA.NUCL poss-rel &
                                                          [ POSS-ED #index ], 
                                                    REST #restr1 ] ] !>,
             P-STORE <! !> ],
       WH <! !> ],
  ARG-ST < > ].

;;;JTB 07/18/01 - Trying to ditch all pumping rules.  Here eliminating
;;;phrase restrictions on COMPS and SUBJ and SPR.

;;;JTB 07/22/01 - Semantics????

p-lxm := const-lxm &
 [ SS.LOC [ CAT [ HEAD prep,
                  SPR < >,
                  COMPS < [ LOC [ CAT [ HEAD noun & [ CASE acc ],
                                        SPR < >,
                                        COMPS  < > ] ] ] > ] ] ].

;;;JTB 07/10/01 marking one shouldn't have a subject, predicative one
;;;should.  07/24/01 Hoping to ditch these two types and make
;;;predicative ones out of non-predicative ones.

mkp-lxm := p-lxm & str-intr &
 [ SS.LOC [ CAT [ HEAD [ PRED false,
                         FORM mkp-pform ],
                  SUBJ < >,
                  COMPS < [ LOC.CONT #cont ] > ],
            CONT #cont ] ].

pdp-lxm := p-lxm & 
 [ SS [ WH <! !>,
        LOC [ CAT [ HEAD [ PRED true,
                           FORM pdp-pform ],
                    SUBJ < synsem & [ LOC [ CAT [ HEAD noun ],
                                            CONT.INDEX #index,
                                            Q-STORE <! !>,
                                            P-STORE <! !> ] ] > ], 
              CONT soa & [ NUCL.ARG #index ] ] ] ].

comp-lxm := const-lxm &
 [ SS [ LOC.CAT [ HEAD comp,
                  SUBJ < >, 
                  SPR < > ],
        WH <! !> ] ].


;;; CCB - this is just a quick definiton.  Needs to be fixed.

;;;JTB - 07/23/01 - We're going to derive ADJs from a simpler
;;;definition so we can get both attributive and predicative.
;;;Consequently, we'll lose the MOD values and stuff and derive all of
;;;the necessary stuff via lexical rules.  And at present, we'll only
;;;worry about predicative ones.  Furthermore, all ADJs will have
;;;specifiers and we'll lose then with a bare-adj rule like with
;;;nouns.

adj-lxm := const-lxm &
 [ SS.LOC [ CAT [ HEAD adj & [ PRED true,
                               FORM normal,
                               DEG /l #deg ],
                  SUBJ < synsem & [ LOC [ CAT.HEAD noun,
                                          CONT.INDEX #index,
                                          Q-STORE <! !>,
                                          P-STORE <! !> ] ] >,
                  SPR /l < [ LOC.CAT.HEAD det & [ DEG #deg ] ] >,
                  COMPS /l < > ],
            CONT soa & [ NUCL.ARG #index ],
            Q-STORE <! !> ] ].

;;; CCB - this is just a quick definiton.  Needs to be fixed.
adv-lxm := const-lxm &
 [ SS.LOC.CAT [ HEAD adv,
                SUBJ < >,
                SPR < >,
                COMPS < > ] ].

;;; <<< >>> ARGUMENT SELECTION

; no-arguments (no-args)
no-args := lexeme &
[ ARG-ST < > ].

; intransitive (intr)
intr := lexeme &
[ ARG-ST < [ LOC.CAT.HEAD.PRED /l false ], ... > ].

; strict-intransitive (str-intr)
str-intr := intr &
[ ARG-ST < [ LOC.CAT.HEAD.PRED /l false ] > ].

; intransitive-xcomp (intr-xcomp)
intr-xcomp := intr &
[ ARG-ST < [ LOC.CAT.HEAD.PRED /l false ], 
           [ LOC.CAT.HEAD.PRED /l false ] > ].

;;;JTB 07/29/01 - Added <! !> constraints to prevent extra
;;;amalgamation.

; subject-control (s-con)
s-con := intr-xcomp &
[ ARG-ST < [ LOC [ CONT [ INDEX #1 ] ] ], 
           [ LOC.CAT [ SUBJ < [ LOC [ CONT [ INDEX #1 ],
                                      P-STORE <! !>,
                                      Q-STORE <! !> ],
                                SLASH <! !> ] >,
                       COMPS < > ] ] > ].

; transitive (tran)
tran := lexeme &
[ ARG-ST < [ LOC.CAT.HEAD.PRED /l false ], 
           [ LOC.CAT.HEAD.PRED /l false ], ... > ].

; strict-transitive (str-tr)
str-tr := tran &
[ ARG-ST < synsem, synsem > ].

; transitive-xcomp (tran-xcomp)
tran-xcomp := tran &
[ ARG-ST < synsem, synsem, synsem & [ LOC.CAT.HEAD.PRED /l false ]> ].

;;; <<< >>> Maximal Subtypes of PART-OF-SPEECH and ARG-SELECTION

; strict-intransitive-verb (siv)
siv := non-auxv-lxm & str-intr.

; subject-control-verb (scv)
scv := non-auxv-lxm & s-con.

; subject-raising-verb (srv)
srv := non-auxv-lxm & s-rais.

; PP-argument (prep-arg)

;;;JTB 07/18/01 - Trying to ditch all pumping rules.  Here eliminating
;;;phrase restrictions on COMPS and SUBJ and SPR.

prep-arg := lexeme &
[ ARG-ST < [ LOC.CAT.HEAD.PRED /l false ], 
           [ LOC.CAT [ HEAD prep & [ PRED false,
                                     FORM mkp-pform ],
                       SPR < >,
                       SUBJ < >,
                       COMPS < > ] ] > ].

; NP-transitive-argument (NP-trans-arg) - Added by CCB 9/9/99
NP-trans-arg := tran &
[ ARG-ST < synsem, [ LOC.CAT [ HEAD noun,
                               SPR < >,
                               COMPS < > ] ] > ].

; ditransitive-argument (ditrans-arg) - Added by CCB 9/9/99
ditrans-arg := lexeme &
[ ARG-ST < [ LOC.CAT.HEAD.PRED /l false ], 
           [ LOC.CAT.HEAD.PRED /l false ], 
           [ LOC.CAT.HEAD.PRED /l false ] > ].

; dative-argument (dt-arg) - Added by CCB 9/9/99
dt-arg := ditrans-arg &
[ ARG-ST < synsem, [ LOC.CAT [ HEAD noun,
                               SPR < >,
                               COMPS < > ] ], 
                   [ LOC.CAT [ HEAD noun,
                               SPR < >,
                               COMPS < > ] ] > ].

; PP-ditransitive (ptv-arg) - Added by CCB 9/9/99
ptv-arg :=  ditrans-arg &
[ ARG-ST < synsem, [ LOC.CAT [ HEAD noun,
                               SPR < > ] ],
                   [ LOC.CAT [ HEAD prep & [ PRED false,
                                             FORM mkp-pform ],
                               SPR < >,
                               SUBJ < >,
                               COMPS < > ] ] > ].

; subject-raising (s-rais)
s-rais := lexeme &
[ SS.LOC.CAT.SUBJ < #2 >,
  ARG-ST < #2 & [ LOC [ CAT #1 & [ HEAD.PRED /l false ],
                        CONT #3 ] ], 
           [ LOC.CAT [ SUBJ < [ LOC [ CAT #1,
                                      CONT #3,
                                      Q-STORE <! !>,
                                      P-STORE <! !> ],
                                SLASH <! !> ] >,
                       COMPS < >,
                       HEAD.PRED /l false ] ] > ].

; PP-intransitive-verb (piv)
piv := non-auxv-lxm & prep-arg.

; strict-transitive-verb (stv)
stv := non-auxv-lxm & NP-trans-arg.


ctv := non-auxv-lxm & str-tr &
[ ARG-ST < synsem, [ LOC [ CAT [ HEAD verbal & [ FORM fin ],
                                 SPR < >,
                                 COMPS < > ],
                           CONT proposition ] ] > ].

; dative-verb (dtv)
dtv := non-auxv-lxm & dt-arg.

; PP-transitive-verb (ptv)
ptv := non-auxv-lxm & ptv-arg.


;;; <<>> Adjective Lexeme types.

; strict-intransitive-adjective (sia)
sia := adj-lxm & str-intr.

; PP-intransitive-adjective (pia)
pia := adj-lxm & prep-arg.

; strict-transitive-adjective (sta)
sta := adj-lxm & str-tr.

; subject-raising-adjective (sra)
sra := adj-lxm & s-rais.

; subject-control-adjective (sca)
sca := adj-lxm & s-con.

;;;JTB - 07/13/01 finding commonality in wh words.  All CAT features
;;;but HEAD are common, as well as SLASH, REL, DTRS.

wh-lxm:=inflected-lexeme+amalg &
[ SS [ LOC [ CAT [ SUBJ < >,
                   SPR < >,
                   COMPS < > ], 
	     CONT scope-obj],
       SLASH <! !>,
       REL <! !> ],
  ARG-ST < >,        
  DTRS < inflected-lexeme > ].

;;;Exclamative vs. non-exclamative

wh-lxm-nexcl:=wh-lxm &
[ SS.LOC.CONT #1 & param,
  SS.LOC.P-STORE <! #1 !> ].

wh-lxm-excl:=wh-lxm & wh-det-lxm &
[ SS.LOC.CONT unusual-rel & #1,
  SS.WH <! #1 !> ].

;;; Noun vs. determiner vs. possessive determiner wh-lxms

wh-n-lxm:=wh-lxm &
[ SS.LOC.CAT.HEAD noun & [ FORM normal,
	        	   ANA false,
                           AGR ref-index,
                           MOD < > ],
  SS.LOC.CONT [ INDEX #index,
                RESTR < [ PROP.SOA.NUCL.ARG #index ] > ],
  SS.LOC.Q-STORE <! !> ].

wh-det-lxm := det-lxm &
[ SS.LOC [ CAT.HEAD.SPEC /l [ INDEX #index,
                              RESTR #restr ],
           CONT #cont & /l [ INDEX #index,
                             RESTR #restr ],
           Q-STORE <! !>,
           P-STORE <! #cont !> ] ].

wh-poss-det-lxm := det-lxm &
[ SS [ LOC [ CAT [ HEAD [ DEG true,
                          SPEC [ INDEX #index,
                                 RESTR #restr1 ] ] ],
             CONT param & [ INDEX #ind2, 
                            RESTR < [ PROP.SOA.NUCL person-rel &
                                       [ ARG #ind2 ] ] > ],
             Q-STORE <! the-rel & [ INDEX #index,
                                    RESTR [ FIRST.PROP.SOA.NUCL poss-rel &
                                             [ POSS-ER #ind2,
                                               POSS-ED #index ], 
                                            REST #restr1 ] ] !> ] ] ].

;;; Focused vs. non-focused in the non-exclamatives

wh-lxm-foc:=wh-lxm-nexcl &
[ SS.LOC.CONT.FOC true,
  SS.WH <! !> ].

wh-lxm-unfoc:=wh-lxm-nexcl &
[ SS.LOC.CONT #1 & [ FOC false ],
  SS.WH <! #1 !> ].

;;; Maximal types

wh-n-lxm-unfoc:=wh-n-lxm & wh-lxm-unfoc.
wh-n-lxm-foc:=wh-n-lxm & wh-lxm-foc.
wh-det-lxm-unfoc:=wh-det-lxm & wh-lxm-unfoc.
wh-det-lxm-foc:=wh-det-lxm & wh-lxm-foc.

wh-poss-det-lxm-foc := wh-poss-det-lxm & wh-lxm-foc.
wh-poss-det-lxm-unfoc := wh-poss-det-lxm & wh-lxm-unfoc.

;;;JTB 07/20/01 - Put these here for now.  These are supertypes of
;;;amalgamation rules.  Now split between soa and scope-obj, although
;;;complementizers don't get amalgamated anymore.

inflected-lexeme+amalg-0 := inflected-lexeme+amalg &
[ SS [ SLASH <! !>,
       WH <! !>,
       LOC [ P-STORE <! !> ] ],
  ARG-ST < >,
  DTRS < inflected-lexeme+ARP > ].

inflected-lexeme+amalg-1 := inflected-lexeme+amalg &
 [ SS [ SLASH #slash,
        WH #wh,
        LOC.P-STORE #store ],
  ARG-ST < [ SLASH #slash,
             WH #wh,
             LOC.P-STORE #store ] >,
  DTRS < inflected-lexeme+ARP > ].

inflected-lexeme+amalg-2 := inflected-lexeme+amalg &
[ SS.LOC.P-STORE [ LIST #store_1,
                   LAST #store_last ], 
 ARG-ST < [ LOC.P-STORE [ LIST #store_1,
                          LAST #store_2 ] ], [ LOC.P-STORE [ LIST #store_2,
                                                             LAST #store_last ] ] >,
 SS.SLASH [ LIST #slash_1,
            LAST #slash_last ], 
 ARG-ST < [ SLASH [ LIST #slash_1,
                    LAST #slash_2 ] ], [ SLASH [ LIST #slash_2,
                                                 LAST #slash_last ] ] >,
 SS.WH [ LIST #wh_1,
         LAST #wh_last ], 
 ARG-ST < [ WH [ LIST #wh_1,
                 LAST #wh_2 ] ], [ WH [ LIST #wh_2,
                                        LAST #wh_last ] ] >,
  DTRS < inflected-lexeme+ARP > ].


inflected-lexeme+amalg-3 := inflected-lexeme+amalg &
[ SS.LOC.P-STORE [ LIST #store_1,
                 LAST #store_last ], 
  ARG-ST < [ LOC.P-STORE [ LIST #store_1,
                         LAST #store_2 ] ], [ LOC.P-STORE [ LIST #store_2,
                                                          LAST #store_3 ] ], [ LOC.P-STORE [ LIST #store_3,
                LAST #store_last ] ] >,
 SS.SLASH [ LIST #slash_1,
            LAST #slash_last ], 
 ARG-ST < [ SLASH [ LIST #slash_1,
                    LAST #slash_2 ] ], [ SLASH [ LIST #slash_2,
                                                 LAST #slash_3 ] ], [ SLASH [ LIST #slash_3,
                                                                              LAST #slash_last ] ] >,
 SS.WH [ LIST #wh_1,
         LAST #wh_last ], 
 ARG-ST < [ WH [ LIST #wh_1,
                 LAST #wh_2 ] ], [ WH [ LIST #wh_2,
                                        LAST #wh_3 ] ], [ WH [ LIST #wh_3,
                                                               LAST #wh_last ] ] >,
  DTRS < inflected-lexeme+ARP > ].
        

inflected-lexeme+amalg-4 := inflected-lexeme+amalg &
[ SS.LOC.P-STORE [ LIST #store_1,
                 LAST #store_last ], 
  ARG-ST < [ LOC.P-STORE [ LIST #store_1,
                         LAST #store_2 ] ], [ LOC.P-STORE [ LIST #store_2,
                                                          LAST #store_3 ] ], [ LOC.P-STORE [ LIST #store_3, 
        LAST #store_4 ] ],  [ LOC.P-STORE [ LIST #store_4,
                                          LAST #store_last ] ]  >,
 SS.SLASH [ LIST #slash_1,
            LAST #slash_last ], 
 ARG-ST < [ SLASH [ LIST #slash_1,
                    LAST #slash_2 ] ], [ SLASH [ LIST #slash_2,
                                                 LAST #slash_3 ] ], [ SLASH [ LIST #slash_3,
           LAST #slash_4 ] ],  [ SLASH [ LIST #slash_4,
                                         LAST #slash_last ] ]  >,
 SS.WH [ LIST #wh_1,
         LAST #wh_last ], 
 ARG-ST < [ WH [ LIST #wh_1,
                         LAST #wh_2 ] ], [ WH [ LIST #wh_2,
                                                LAST #wh_3 ] ], 
    [ WH [ LIST #wh_3,
           LAST #wh_4 ] ],  [ WH [ LIST #wh_4,
                                       LAST #wh_last ] ]  >,
  DTRS < inflected-lexeme+ARP > ].

;;;JTB - generalized inflectional rules.  I'll add to this some stuff
;;;about predicative vs. non-predicative.


;const-lxm_infl := inflected-lexeme & 
;[ ORTH #orth,
;  DTRS < const-lxm & [ ORTH #orth,
;                       NEEDS-AFFIX false ] > ].

;sg-cn-lxm-infl := sing-noun_infl.
;pl-cn-lxm-infl := plur-common-noun_infl.


const-lxm_infl := inflected-lexeme & 
[ ORTH #orth,
  DTRS < const-lxm & [ ORTH #orth,
                       NEEDS-AFFIX false ] > ].

attrib-prep-lxm_infl := attrib-lxm_infl &
[ SS.LOC.CAT.HEAD prep, 
  DTRS < pdp-lxm > ].

attrib-adj-lxm_infl := attrib-lxm_infl &
[ SS.LOC.CAT.HEAD adj & /l [ SPEC.INDEX #index ],
  SS.LOC.CONT.NUCL.ARG /l #index, 
  DTRS < adj-lxm > ].

attrib-lxm_infl := const-lxm_infl & 
[ SS.LOC [ CAT [ HEAD [ PRED false,
                        MOD < [ LOC [ CAT.HEAD noun,
                                      CAT.SPR < synsem >,
                                      CONT.INDEX #index ] ] > ],
                 SUBJ < > ],
           CONT.NUCL.ARG #index ],
  DTRS < [ SS.LOC.CAT.HEAD.PRED true ] > ].

;;;JTB 07/24/01 - Do this with the semantics for now but check with
;;;Ivan eventually.

;pred-lxm := inflected-lexeme &
;[ SS.LOC [ CAT [ HEAD.PRED true,
;                 SUBJ < synsem > ],
;           CONT soa ] ].

;non-pred-lxm := inflected-lexeme &
;[ SS.LOC.CAT [ HEAD.PRED false,
;               SUBJ < > ] ].

;pred-n-lxm := pred-lxm &
;[ SS.LOC [ CAT [ HEAD.PRED true,
;                 SUBJ < synsem & [ LOC [ CONT.INDEX #index,
;                                         Q-STORE <! !>,
;                                         P-STORE <! !> ],
;                                   SLASH <! !> ] > ],
;           CONT soa & [ NUCL.INSTANCE #index ] & #soa ],
;  DTRS < n-lxm & [ SS.LOC.CONT.RESTR < [ PROP.SOA #soa ] > ] > ].

;non-pred-n-lxm := inflected-lexeme &
;[ SS.LOC.CAT [ HEAD.PRED false,
;               SUBJ < > ],
;  DTRS < n-lxm > ].

;;;

