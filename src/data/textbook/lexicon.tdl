;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; SYNTACTIC THEORY by Sag and Wasow -- Textbook Grammar 
;;; implementation by Chris Callison-Burch & Scott Guffey
;;;
;;; lexicon.tdl
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; <<>> ----- NON-REFLEXIVE PRONOUN DEFINITIONS  -----

:begin :instance.
i_1 := pron-lxm & 
[ ORTH <! "i" !>,
  SYN  [ HEAD noun & [ AGR non-3sing & [ PER 1st ],
		       CASE nom ] ],
  SEM [ RESTR <! [RELN r_speaker] !> ] ].      
:end :instance.

; <<>>

:begin :instance.
me_1 := pron-lxm & 
[ ORTH <! "me" !>,
  SYN  [ HEAD noun & [ AGR non-3sing & [ PER 1st ],
		       CASE acc ] ],
  SEM [ RESTR <! [RELN r_speaker] !> ] ].
:end :instance.

; <<>>

:begin :instance.
she_1 := pron-lxm & 
[ ORTH <! "she" !>,
  SYN  [ HEAD noun & [ AGR 3sing & [PER 3rd, GEND fem ], 
		       CASE nom ] ],
  SEM [ RESTR <! [RELN r_female] !> ] ].
:end :instance.

; <<>>

:begin :instance.
her_1 := pron-lxm & 
[ ORTH <! "her" !>,
  SYN  [ HEAD noun & [ AGR 3sing & [PER 3rd, GEND fem ], 
		       CASE acc ] ],
  SEM [ RESTR <! [RELN r_female] !> ] ].
:end :instance.

; <<>>

:begin :instance.
he_1 := pron-lxm & 
[ ORTH <! "he" !>,
  SYN  [ HEAD noun & [ AGR 3sing & [PER 3rd, GEND masc ], 
		       CASE nom ] ],
  SEM [ RESTR <! [RELN r_male] !> ] ].
:end :instance.

; <<>>

:begin :instance.
him_1 := pron-lxm & 
[ ORTH <! "him" !>,
  SYN  [ HEAD noun & [ AGR 3sing & [PER 3rd, GEND masc ], 
		       CASE acc ] ],
  SEM [ RESTR <! [RELN r_male] !> ] ].
:end :instance.

; <<>>

:begin :instance.
you_1 := pron-lxm & 
[ ORTH <! "you" !>,
  SYN  [ HEAD noun & [ AGR non-3sing & [PER 2nd],
		       CASE nom] ],
  SEM [ RESTR <! [RELN r_hearer] !> ] ].
:end :instance.

; <<>>

:begin :instance.
you_2 := pron-lxm & 
[ ORTH <! "you" !>,
  SYN  [ HEAD noun & [ AGR non-3sing & [PER 2nd],
		       CASE acc] ],
  SEM [ RESTR <! [RELN r_hearer] !> ] ].
:end :instance.

; <<>>

; This semantics is problematic if we have they/them inherit from it.  Perhaps they 
; and them should have their own lexical entries...  SMG
;
:begin :instance.
it_1 := pron-lxm & 
[ ORTH <! "it" !>,
  SYN  [ HEAD noun & [ AGR [PER 3rd, GEND neut] ] ],
  SEM [ RESTR <! [RELN r_thing] !> ] ].
:end :instance.

; <<>>

; The problem here is that the subject/verb agreement information is disjoint from the anaphoric 
; agreement information, something very tricky to solve in our grammar.  ("They love themselves")
;
:begin :instance.
nobody_1 := pron-lxm & 
[ ORTH <! "nobody" !>,
  SYN  [ HEAD noun & [ AGR 3sing ] ],
  SEM [ RESTR <! [RELN r_no-person] !> ] ].
:end :instance.

; <<>>

:begin :instance.
everybody_1 := pron-lxm & 
[ ORTH <! "everybody" !>,
  SYN  [ HEAD noun & [ AGR 3sing] ],
  SEM [ RESTR <! [RELN r_every-person] !> ] ].
:end :instance.


;;; <<>> ----- REFLEXIVE PRONOUN DEFINITIONS  -----

:begin :instance.
myself_1 := reflex-pron-lxm & 
[ ORTH <! "myself" !>,
  SYN  [ HEAD noun & [ AGR [ PER 1st ],
		       CASE acc ] ] ].
:end :instance.

; <<>>

:begin :instance.
yourself_1 := reflex-pron-lxm & 
[ ORTH <! "yourself" !>,
  SYN  [ HEAD noun & [ AGR non-3sing & [ PER 2nd ],
		       CASE acc ] ] ].
:end :instance.

; <<>>

:begin :instance.
herself_1 := reflex-pron-lxm & 
[ ORTH <! "herself" !>,
  SYN  [ HEAD noun & [ AGR 3sing & [GEND fem],
		       CASE acc ] ],
  SEM [ RESTR <! [RELN r_female] !> ] ].
:end :instance.

; <<>>

:begin :instance.
himself_1 := reflex-pron-lxm & 
[ ORTH <! "himself" !>,
  SYN  [ HEAD noun & [ AGR 3sing & [GEND masc],
		       CASE acc ] ],
  SEM [ RESTR <! [RELN r_male] !> ] ].
:end :instance.

; <<>>

:begin :instance.
itself_1 := reflex-pron-lxm & 
[ ORTH <! "itself" !>,
  SYN  [ HEAD noun & [ AGR [PER 3rd, GEND neut],
		       CASE acc ] ] ].
:end :instance.

; <<>> 
; Do we really want an entry for themself or is its usage not grammatically correct?
;
:begin :instance.
themself_1 := reflex-pron-lxm & 
[ ORTH <! "themself" !>,
  SYN  [ HEAD noun & [ AGR 3sing,
		       CASE acc ] ] ].
:end :instance.

; <<>>

:begin :instance.
themselves_1 := reflex-pron-lxm & 
[ ORTH <! "themselves" !>,
  SYN  [ HEAD noun & [ AGR 3sing,
		       CASE acc ] ] ].
:end :instance.


;;; <<>> ----- NONGENDERED PROPER NAMES -----

:begin :instance.
kim_1 := pn-lxm & 
[ ORTH <! "kim" !>,
  SEM [ RESTR <! [ NAME 'Kim ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
sandy_1 := pn-lxm & 
[ ORTH <! "sandy" !>,
  SEM [ RESTR <! [ NAME 'Sandy ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
pat_1 := pn-lxm & 
[ ORTH <! "pat" !>,
  SEM [ RESTR <! [ NAME 'Pat ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
Chicago_1 := pn-lxm & 
[ ORTH <! "Chicago" !>,
  SYN [ HEAD [ AGR [ GEND neut ] ] ],  
  SEM [ RESTR <! [ NAME 'Chicago ] !> ] ].
:end :instance.


;;; <<>> ----- GENDERED PROPER NAMES  -----

:begin :instance.
tarzan_1 := pn-lxm &
[ ORTH <! "tarzan" !>,
  SYN [ HEAD noun & [AGR [GEND masc] ] ],
  SEM [ RESTR <! [ NAME 'Tarzan ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
jane_1 := pn-lxm &
[ ORTH <! "jane" !>,
  SYN [ HEAD noun & [AGR [GEND fem] ] ],
  SEM [ RESTR <! [ NAME 'Jane ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
romeo_1 := pn-lxm &
[ ORTH <! "romeo" !>,
  SYN [ HEAD noun & [AGR [GEND masc] ] ],
  SEM [ RESTR <! [ NAME 'Romeo ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
juliet_1 := pn-lxm &
[ ORTH <! "juliet" !>,
  SYN [ HEAD noun & [AGR [GEND fem] ] ],
  SEM [ RESTR <! [ NAME 'Juliet ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
clyde_1 := pn-lxm &
[ ORTH <! "clyde" !>,
  SYN [ HEAD noun & [AGR [GEND masc] ] ],
  SEM [ RESTR <! [ NAME 'Clyde ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
bonnie_1 := pn-lxm &
[ ORTH <! "bonnie" !>,
  SYN [ HEAD noun & [AGR [GEND fem] ] ],
  SEM [ RESTR <! [ NAME 'Bonnie ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
America_1 := pn-lxm &
[ ORTH <! "America" !>,
  SYN [ HEAD [ AGR [ GEND fem ] ] ],  
  SEM [ RESTR <! [ NAME 'America ] !> ] ].
:end :instance.


;;; <<>> ----- COMMON NOUN LEXICAL ENTRIES  -----

:begin :instance.
table_1 := cn-lxm & 
[ ORTH <! "table" !>,
  SYN [ SPR < [ SYN [ HEAD [COUNT true] ] ] > ],  
  SEM [ RESTR <! [ RELN r_table ] !> ] ].
:end :instance.

;  The entry for furniture currently has an attribute of NUM plur so that it can feed through a
;  count-false-lexical-rule (which isn't in the book) and allow for things of the form "All furniture..." SMG
;
; <<>>

:begin :instance.
furniture_1 := cn-lxm & 
[ ORTH <! "furniture" !>,
  SYN [	HEAD [ AGR [ NUM plur ] ],
	SPR < [ SYN [ HEAD [COUNT false] ] ] > ],  
  SEM [ RESTR <! [ RELN r_table ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
book_1 := cn-lxm & 
[ ORTH <! "book" !>,
  SYN [ SPR < [ SYN [ HEAD [COUNT true] ] ] > ],
  SEM [ RESTR <! [ RELN r_book ] !> ] ].
:end :instance.

; <<>>

; This book below is the one which comes into play for cases of "I love the book about myself" 
;
:begin :instance.
book_2 := noun-lxm & 
[ ORTH <! "book" !>,
  SYN [ HEAD noun & [ FORM normal, 
		      AGR #agr & [ PER 3rd, GEND neut ],
		      COUNT true ],
	SPR < [ SYN [ HEAD det & [ COUNT true, AGR #agr ],
		      SPR < > ] ] >,
	COMPS < [ SYN [ HEAD prep & [FORM f_about] ] ] > ],
  SEM [ RESTR <! [ RELN r_book ] ! > ] ].
:end :instance.

; <<>>

:begin :instance.
picture_1 := cn-lxm & 
[ ORTH <! "picture" !>,
  SYN [ SPR < [ SYN [ HEAD [COUNT true] ] ] > ],
  SEM [ RESTR <! [ RELN r_picture ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
picture_2 := noun-lxm & 
[ ORTH <! "picture" !>,
  SYN [ HEAD noun & [ FORM normal, 
		      AGR #agr & [ PER 3rd, GEND neut ],
		      COUNT true ],
	SPR < [ SYN [ HEAD det & [ COUNT true, AGR #agr ],
		      SPR < > ] ] >,
	COMPS < [ SYN [ HEAD prep & [FORM f_of] ] ] > ],
  SEM [ RESTR <! [ RELN r_picture ] ! > ] ].
:end :instance.

; <<>>

:begin :instance.
cause_1 := cn-lxm & 
[ ORTH <! "cause" !>,
  SYN [ SPR < [ SYN [ HEAD [COUNT true] ] ] > ],
  SEM [ RESTR <! [ RELN r_cause ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
idea_1 := cn-lxm & 
[ ORTH <! "idea" !>,
  SYN [ SPR < [ SYN [ HEAD [COUNT true] ] ] > ],
  SEM [ RESTR <! [ RELN r_idea ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
cat_1 := cn-lxm & 
[ ORTH <! "cat" !>,
  SYN [ SPR < [ SYN [ HEAD [COUNT true] ] ] > ],
  SEM [ RESTR <! [ RELN r_cat ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
goose_1 := cn-lxm & 
[ ORTH <! "goose" !>,
  SYN [ HEAD [ AGR [ NUM sing ] ],
	SPR < [ SYN [ HEAD [COUNT true] ] ] > ],
  SEM [ RESTR <! [ RELN r_goose] !> ] ].
:end :instance.

; <<>>

:begin :instance.
ice_cream_1 := cn-lxm & 
[ ORTH <! "ice", "cream" !>,
  SYN [ HEAD [ AGR [ NUM plur ] ],
	SPR < [ SYN [ HEAD [COUNT false] ] ] > ],
  SEM [ RESTR <! [ RELN r_ice-cream] !> ] ].
:end :instance.

; <<>>

:begin :instance.
Andes_1 := cn-lxm & 
[ ORTH <! "Andes" !>,
  SYN [ SPR < [ SYN [ HEAD [COUNT true] ] ] > ],
  SEM [ RESTR <! [ RELN r_Ande] !> ] ].
:end :instance.



;;; <<>> ----- IDIOMATIC/DUMMY TYPES  -----

:begin :instance.
tabs_1 := dummy-idiom-lxm &
[ ORTH <! "tabs" !>,
  SYN [ HEAD [ FORM f_tabs ] ] ].
:end :instance.

; <<>>

:begin :instance.
advantage1 := dummy-idiom-lxm &
[ ORTH <! "advantage" !>,
  SYN [ HEAD [ FORM f_advantage] ] ].
:end :instance.

; <<>>

:begin :instance.
it_2 := dummy-idiom-lxm &
[ ORTH <! "it" !>,
  SYN   [ HEAD [ FORM f_it,
		 AGR 3sing ] ] ].
:end :instance.

; <<>>

:begin :instance.
there_1 := dummy-idiom-lxm & 
[ ORTH <! "there" !>,
  SYN  [ HEAD [ FORM f_there,
		AGR [ PER 3rd ] ] ] ].
:end :instance.


;;; <<>> ----- DETERMINERS  -----

; 's was made of type const-lxm because the ARG-ST of det-lxm is empty.  SMG
;
:begin :instance.
s_1 := const-lxm &
[ ORTH <! "s" !>,
  SYN [ HEAD det,
	SPR < [ SYN [ HEAD noun ],
		ARG-ST < > ] > ],
  SEM null-sem].
:end :instance.

; <<>>

:begin :instance.
the_1 := det-lxm & 
[ ORTH <! "the" !> ].
:end :instance.

; <<>>

:begin :instance.
a_1 := det-lxm & 
[ ORTH <! "a" !>,
  SYN [ HEAD [ COUNT true,
	       AGR [ NUM sing ] ] ] ].
:end :instance.

; <<>>

:begin :instance.
this_1 := det-lxm & 
[ ORTH <! "this" !>,
  SYN [ HEAD [ AGR [ NUM sing ] ] ] ].
:end :instance.

; <<>>

:begin :instance.
that_1 := det-lxm & 
[ ORTH <! "that" !>,
  SYN [ HEAD [ AGR [ NUM sing ] ] ] ].
:end :instance.

; <<>>


:begin :instance.
few_1 := det-lxm & 
[ ORTH <! "few" !>,
  SYN [ HEAD [ COUNT true,
	       AGR non-3sing & [ NUM plur ] ] ] ].
:end :instance.

; <<>>

:begin :instance.
many_1 := det-lxm & 
[ ORTH <! "many" !>,
  SYN [ HEAD [ COUNT true,
	       AGR non-3sing & [ NUM plur ] ] ] ].
:end :instance.

; <<>>

:begin :instance.
much_1 := det-lxm & 
[ ORTH <! "much" !>,
  SYN [ HEAD [ COUNT false ] ] ].
:end :instance.


; Do we want to try to produce a interpretation of quantifier syntax.  If so we have to find some
; way of allowing both "all chairs" as well as "all furniture".    Right now things seem to work
; okay as long as we have furniture listed in the irregs file as a plural noun.  SMG

; <<>>

:begin :instance.
all_1 := det-lxm & 
[ ORTH <! "all" !>,
  SYN [ HEAD [ AGR non-3sing & [ NUM plur ] ] ] ].
:end :instance.

; <<>>

:begin :instance.
no_1 := det-lxm & 
[ ORTH <! "no" !>,
  SYN [ HEAD [ AGR non-3sing & [ NUM plur ] ] ] ].
:end :instance.


;;; <<>> ----- PREPOSITIONS  -----

:begin :instance.
to_1 := mkp-lxm & 
[ ORTH <! "to" !>,
  SYN [ HEAD [FORM f_to ] ] ].
:end :instance.

; <<>>

; The entry below is necessary for instances of "told...about"
;
:begin :instance.
about_1 :=mkp-lxm &
[ ORTH <! "about" !>,
  SYN [HEAD [FORM f_about ],
      COMPS < [SYN [HEAD noun ] ] > ] ].
:end :instance.

; <<>>

;:begin :instance.
;about_2 := pdp-lxm &
;[ ORTH <! "about" !>,
;  SYN [ HEAD [ FORM f_about,
;	       MOD < [ SYN [ HEAD noun ] ] > ] ] ].
;:end :instance.

; <<>>

:begin :instance.
on_1 := mkp-lxm &
[ ORTH <! "on" !>,
  SYN [ HEAD [ FORM f_on ] ] ].
:end :instance.

; <<>>

:begin :instance.
on_2 := pdp-lxm &
[ ORTH <! "on" !>,
  SYN [ HEAD [ FORM f_on,
	       MOD < [ SYN [ HEAD noun ] ] > ] ] ].
:end :instance.

; <<>>

:begin :instance.
on_3 := pdp-lxm &
[ ORTH <! "on" !>,
  SYN [ HEAD [ FORM f_on,
	       MOD < [ SYN [ HEAD verb ] ] > ] ] ].
:end :instance.

; <<>>

:begin :instance.
of_1 := mkp-lxm &
[ ORTH <!  "of" !>,
  SYN [ HEAD [ FORM f_of ] ] ].
:end :instance.

; <<>>

:begin :instance.
for_1 := mkp-lxm &
[ ORTH <!  "for" !>,
  SYN [ HEAD [ FORM f_for ] ] ].
:end :instance.

; <<>>

; Seems like we'll need a pdp-lxm for by as well to account for "I dropped the
; book by the store." 
;
:begin :instance.
by_1 := mkp-lxm & 
[ ORTH <!  "by" !>,
  SYN [ HEAD [ FORM f_by ] ] ].
:end :instance.



;;; <<>> ----- ADVERBS, ADJECTIVES, COMPLIMENTIZERS, CONJUNCTIONS...  -----

:begin :instance.
that_2 := comp-lxm & 
[ ORTH <! "that" !>,
  SYN [HEAD [ FORM fin ] ],
  ARG-ST < [SYN [SPR < > ] ] > ].
:end :instance.

; <<>>

:begin :instance.
to_2:= comp-lxm & 
[ ORTH <! "to" !>,
  SYN [ HEAD [ FORM inf ],
	SPR < [ ] > ],
  ARG-ST < #1, [SYN [SPR < #1 > ] ] > ].
:end :instance.

; <<>>

:begin :instance.
not_1 := adv-lxm & 
[ ORTH <! "not" !>,
  SYN  [ HEAD adv & [ MOD < [SYN [HEAD [AUX false ] ] ] >,
		      FORM f_not ],
	 SPR  < >,
	 COMPS < > ],
  SEM [ RESTR <! [RELN r_not] !> ] ].
:end :instance.

; <<>>

:begin :instance.
and_1 := conj-lxm &
[ ORTH <! "and" !>,
  SYN [ HEAD [ FORM f_and ] ] ].
:end :instance.

; <<>>

:begin :instance.
quickly_1 := adv-lxm &
[ ORTH <! "quickly" !>,
  SEM [ RESTR <! [ RELN r_quickly ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
today_1 := adv-lxm &
[ ORTH <! "today" !>,
  SEM [ RESTR <! [ RELN r_today ] !> ] ].
:end :instance.

; <<>>



;;; <<>> ----- VERB LEXICAL ENTRIES  -----

:begin :instance.
die_1 := iv-lxm &
[ ORTH <! "die" !>,
  SEM [ RESTR <! [ RELN r_die ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
sleep_1 := iv-lxm &
[ ORTH <! "sleep" !>,
  SEM  [ RESTR <! [ RELN r_sleep] !> ] ].
:end :instance.

; <<>>

:begin :instance.
vote_1 := iv-lxm &
[ ORTH <! "vote" !>,
  SEM [ RESTR <! [RELN r_vote] !> ] ].
:end :instance.

; <<>>

:begin :instance.
vote_2 := piv-lxm &
[ ORTH <! "vote" !>,
  SYN [ COMPS < [ SYN [ HEAD prep & [ FORM f_for ] ] ] > ],
  SEM [ RESTR <! [RELN r_vote] !> ] ].
:end :instance.

; <<>>

:begin :instance.
eat_1 := iv-lxm &
[ ORTH <! "eat" !>,
  SEM  [ RESTR <! [ RELN r_eat] !> ] ].
:end :instance.

; <<>>

:begin :instance.
eat_2 := stv-lxm &
[ ORTH <! "eat" !>,
  SEM  [ RESTR <! [ RELN r_eat] !> ] ].
:end :instance.

; <<>>

:begin :instance.
kick_1 := stv-lxm &
[ ORTH <! "kick" !>,
  SEM  [ RESTR <! [ RELN r_kick] !> ] ].
:end :instance.

; <<>>

:begin :instance.
love_1 := stv-lxm &
[ ORTH <! "love" !>,
  SEM  [ RESTR <! [ RELN r_love ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
like_1 := stv-lxm &
[ ORTH <! "like" !>,
  SEM  [ RESTR <! [ RELN r_like ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
hate_1 := stv-lxm &
[ ORTH <! "hate" !>,
  SEM  [ RESTR <! [ RELN r_hate ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
give_1 := dtv-lxm &
[ ORTH <! "give" !>,
  SEM  [ RESTR <! [ RELN r_give ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
give_2 := ptv-lxm &
[ ORTH <! "give" !>,
  SYN  [ COMPS <[ ], [SYN [HEAD prep & [FORM f_to ] ] ]> ],
  SEM  [ RESTR <! [ RELN r_give ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
buy_1 := stv-lxm &
[ ORTH <! "buy" !>,
  SEM  [ RESTR <! [ RELN r_buy ] !> ] ].
:end :instance.

; <<>> 

:begin :instance.
buy_2 := dtv-lxm &
[ ORTH <! "buy" !>,
  SEM  [ RESTR <! [ RELN r_buy ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
buy_3 := ptv-lxm &
[ ORTH <! "buy" !>,
  SYN  [ COMPS <[ ], [SYN [HEAD prep & [FORM f_for ] ] ]> ],
  SEM  [ RESTR <! [ RELN r_buy ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
tell_1 := ptv-lxm &
[ ORTH <! "tell" !>,
  SEM  [ RESTR <! [ RELN r_tell ] !> ],
  ARG-ST < [ ], [ ], [ SYN [ HEAD prep ] ] > ].
:end :instance.

; <<>>

:begin :instance.
like_2 := ctv-lxm &
[ ORTH <! "like" !>,
  SEM  [ RESTR <! [ RELN r_like ] !> ] ].
:end :instance.
;    ARG-ST < #1, [SYN [SPR < #1 > ] ] > ].

; <<>>

:begin :instance.
annoy_1 := stv-lxm &
[ ORTH <! "annoy" !>,
  SEM  [ RESTR <! [ RELN r_annoy ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
annoy_2 := verb-lxm &
[ ORTH <! "annoy" !>,
  SEM  [ RESTR <! [ RELN r_annoy ] !> ],
  ARG-ST < [SYN [HEAD noun & [FORM f_it] ] ], [ ], [SYN [HEAD comp,
							 COMPS < > ] ] > ].
:end :instance.



;;; <<>> ----- IDIOMATIC/DUMMY EXPRESSIONS  -----


:begin :instance.

rain_1 := verb-lxm &
[ ORTH <! "rain" !>,
  ARG-ST < [SYN [HEAD noun & [FORM f_it] ],
	    SEM [INDEX #1] ] > ].

:end :instance.

; <<>>

:begin :instance.
keep_1 := verb-lxm &
[ ORTH <! "keep" !>,
  ARG-ST < [ ], [SYN [HEAD noun & [FORM f_tabs] ] ], [SYN [HEAD prep & [FORM f_on,
									ANA #agr],
							   SPR < > ] ] >,
  SEM  [ RESTR <! [ RELN r_observe ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
take_1 := verb-lxm &
[ ORTH <! "take" !>,
  ARG-ST < [ ], [SYN [HEAD noun & [FORM f_advantage] ] ], [SYN [HEAD prep & [FORM f_of,
									     ANA #agr],
								SPR < > ] ] >,
  SEM  [ RESTR <! [ RELN r_exploit ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
kick-the-bucket_1 := iv-lxm &
 [ ORTH <! "kicked the bucket" !>,
   SEM  [ RESTR <! [ RELN r_die] !> ] ].
:end :instance.



;;; <<>> ----- SUBJECT RAISING/CONTROL, OBJECT RAISING/CONTROL  -----

:begin :instance.
continue_1 := srv-lxm &
[ ORTH <! "continue" !>,
  SEM [RESTR <! [RELN r_continue ] !> ],
  ARG-ST < [ ], [SYN [HEAD comp & [FORM inf] ] ] > ].
:end :instance.

; <<>>

:begin :instance.
try_1 := scv-lxm &
[ ORTH <! "try" !>,
  SEM [RESTR <! [RELN r_try ] !> ],
  ARG-ST < [ ], [SYN [HEAD comp ] ] > ].
:end :instance.

; <<>>

:begin :instance.
expect_1 := orv-lxm &
[ ORTH <! "expect" !>,
  SEM [RESTR <! [RELN r_expect ] !> ],
  ARG-ST < [ ], [ ], [SYN [HEAD comp & [FORM inf] ] ] > ].
:end :instance.

; <<>>

:begin :instance.
expect_2 := ctv-lxm &
[ ORTH <! "expect" !>,
  SEM [RESTR <! [RELN r_expect ] !> ] ].
:end :instance.
 
; <<>>

:begin :instance.
persuade_1 := ocv-lxm &
[ ORTH <! "persuade" !>,
  SEM [RESTR <! [RELN r_persuade ] !> ],
  ARG-ST < [ ], [ ], [SYN [HEAD comp ] ] > ].
:end :instance.


;;; <<>> ----- AUXILARY VERBS  -----

:begin :instance.
can_1 := auxv-lxm &
[ ORTH <! "can" !>,
  SYN [ HEAD verb & [ FORM fin ] ],
  ARG-ST < [ ], [ SYN [ HEAD verb & [FORM inf] ] ] >, 
  SEM  [ RESTR <! [ RELN r_can ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
could_1 := auxv-lxm &
[ ORTH <! "could" !>,
  SYN [ HEAD verb & [ FORM fin] ],
  ARG-ST < [ ], [ SYN [ HEAD verb & [FORM inf] ] ] >, 
  SEM  [ RESTR <! [ RELN r_could ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
do_1 := auxv-lxm &
[ ORTH <! "do" !>,
  SYN [ HEAD verb & [ FORM fin ] ], 
  ARG-ST < [ ], [ SYN [ HEAD verb & [FORM inf, AUX false ] ] ] >, 
  SEM  [ RESTR <! [ RELN r_do ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
will_1 := auxv-lxm &
[ ORTH <! "will" !>,
  SYN [ HEAD verb & [ FORM fin ] ], 
  ARG-ST < [ ], [ SYN [ HEAD verb & [FORM inf] ] ] >, 
  SEM  [ RESTR <! [ RELN r_will ] !> ] ].
:end :instance.

; <<>>


:begin :instance.
have_1 := auxv-lxm &
[ ORTH <! "have" !>,
  ARG-ST < [ ], [ SYN [ HEAD verb & [FORM psp] ] ] >, 
  SEM  [ RESTR <! [ RELN r_have ] !> ] ].
:end :instance.

; <<>>

:begin :instance.
be_1 := auxv-lxm &
[ ORTH <! "be" !>,
  SEM [ MODE prop,
	INDEX #ind ],
  ARG-ST < [ ], [ SYN [ HEAD [PRED true] ],
		  SEM [ INDEX #ind ] ] > ].
:end :instance.

; <<>>

; be_2 should inherit from auxv-lxm, but has no way of overridding the 2 place
; arg-st constraint. It cannot inherit from verb-lxm  either, it's AUX false.  
;
:begin :instance.
be_2 := infl-lxm &
[ ORTH <! "be" !>,
 SYN [ HEAD verb & [ AUX true,
		     INV false, 
		     NEG false ],
       SPR < [ ] > ],   
  SEM [INDEX #ind,
      MODE prop], 
  ARG-ST < [SYN [HEAD noun & [FORM f_there] ] ], #1 & [ SYN [HEAD noun] ], [ SYN [ HEAD [PRED true],
										   SPR < #1 > ],
									     SEM [ INDEX #ind] ] > ].
:end :instance.



