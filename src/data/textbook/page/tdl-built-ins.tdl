;***************************************************************************
;*                                                                         *
;* File:     tdl-built-ins.tdl                                             *
;*                                                                         *
;* Purpose:  predefined type kernel (declarations and definitions) of TDL. *
;*                                                                         *
;* Author:   HUK                                                           *
;*                                                                         *
;* Version:  25/11/94, 16:30                                               *
;*                                                                         *
;*           (C) by FoPra Brothers Inc.                                    *
;*                                                                         *
;***************************************************************************

begin :declare.

  built-in:  fixnum, bignum, integer. ;;; only COMMON LISP types can be
  built-in:  atom, string, symbol.    ;;; declared as built-ins

; sort:  *null*.                      ;;; is the type of the empty list < >
  sort:  *built-in*.                  ;;; the top built-in type
  sort:  *sort*.                      ;;; the top sort type
  sort:  *undef*.                     ;;; make *undef* a sort in order to 
                                      ;;; exclude features defined on it
;;;  NIL = *undef* & *built-in*.      ;;; introduce the *undef* type to cope with
;;;  NIL = *undef* & *sort*.          ;;; the need of specifying that an attribute is
;;;  NIL = *undef* & *avm*.           ;;; undefined (non-appropriate) for a certain type
;;;  NIL = *built-in* & *sort*.       ;;; is already hard-wired in XGLB+ and the
;;;  NIL = *built-in* & *avm*.        ;;; closed-world assumption for sort types
;;;  NIL = *avm* & *sort*.            ;;; (subtypes of *SORT* and *BUILT-IN*)
  
end :declare.


begin :type.

  *avm* := [ ].                       ;;; the top avm type

  atom    :< *built-in*.              ;;; now specify the subtype relation for 
  integer :< atom.                    ;;; the built-ins
  fixnum  :< integer.
  bignum  :< integer.
  symbol  :< atom.
  string  :< atom.

  *list* :< *avm*.
  *cons* := *list* &
    [ FIRST [ ],
      REST *list* ].
  *null* :< *list*.

  *diff-list* := *avm* & [LIST, LAST].

;;; diff list version of APPEND
  dl-append := *avm* & [ APPARG1 [LIST #first,       
				  LAST #between],
			 APPARG2 [LIST #between,
				  LAST #last],
			 RES  [LIST #first,
			       LAST #last]].

  *rule* :=                           ;;; the most general rule type
    [ ]  -->  < ... >,                ;;; use [ ] instead of *top*, because *top*
    status: RULE.                     ;;; is only the default top symbol which can
  unary-rule :=                       ;;; overwritten through DEFDOMAIN :top <top>
    *rule*  --> < [ ] >.              ;;; moreover, use the `status' keyword to
  binary-rule :=                      ;;; let Bernie's parser know about the special
    *rule*  --> < [ ], [ ] >.         ;;; role of *rule*
  ternary-rule :=
    *rule*  --> < [ ], [ ], [ ] >.
;;;  nullary-rule :=
;;;    *rule* --> < >.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;  append0 := *avm* & [FRONT < >,                 ;;; Ait-Kaci's version of APPEND:
;;;                      BACK  #1 & *list*,
;;;                      WHOLE #1].
;;;  append1 := *avm* & [FRONT <#first . #rest1>,
;;;                      BACK  #back & *list*,
;;;                      WHOLE <#first . #rest2>,
;;;                      PATCH *append* & [FRONT #rest1,
;;;                                        BACK  #back,
;;;                                        WHOLE #rest2]].
;;;  *append* := append0 \| append1.
;;;
;;;
;;;  less := [ELT #elt,                           ;;; this LESS simulates the less function
;;;           SET #set,                           ;;; *avm* should be the supertype of less
;;;           AUX *append* & [FRONT #front,
;;;                           BACK  < #elt . #rest >,
;;;                           WHOLE #set],
;;;           RES *append* & [FRONT #front,
;;;                           BACK  #rest]].
;;;
;;;  w := less & [ELT [E 0],                      ;;; [E 0] successfully unifies with every
;;;               SET <[A 1],[B 2],[C 3]>].       ;;; element of the SET
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

end :type. 
