;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; SYNTACTIC THEORY by Sag and Wasow -- Textbook Grammar 
;;; implementation by Chris Callison-Burch & Scott Guffey
;;;
;;; grules.tdl
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:begin :instance.
head-specifier-rule := birule-headfinal &
 [ SYN [ SPR < > ],

   NH1 #1, 
   H [ SYN [ SPR < #1 > ] ] ].
:end :instance.


:begin :instance.
head-complement-rule-0 := unary-COMPS-rule & 
 [ SYN [ SPR #spr,  
	 COMPS < > ], 

   H [ SYN [ SPR #spr,
	     COMPS < > ] ] ].
:end :instance.


:begin :instance.
head-complement-rule-1 := binary-COMPS-rule & 
 [ SYN [ SPR #spr,  
	 COMPS < > ], 

   H [ SYN [ SPR #spr,
	     COMPS < #1 > ] ],
   NH1 #1 ].
:end :instance.



:begin :instance.
head-complement-rule-2 := trinary-COMPS-rule & 
 [ SYN [ SPR #spr,  
	 COMPS < > ], 

   H [ SYN [ SPR #spr,
	     COMPS < #1, #2 > ] ],
   NH1 #1,
   NH2 #2 ].
:end :instance.



:begin :instance.
head-modifier-rule := birule-headfirst &
 [ SYN [ SPR < #spr > ],
   
   H #1 & [ SYN [ SPR < #spr > ] ],
   NH1 [ SYN [ HEAD [ MOD < #1 > ] ] ] ].
:end :instance.


:begin :instance.
imperative-rule := unary-grule &
 [ SYN [ HEAD verb & [ FORM fin ],
	 SPR < > ],
   SEM [ MODE dir,
	 INDEX #ind ],

   NH1 [ SYN [ HEAD verb & [ FORM inf ],
	       SPR < [ SYN [ HEAD noun & [ AGR [ PER 2nd ] ] ] ] > ],
	 SEM [ INDEX #ind ] ] ].
:end :instance.


:begin :instance.
bare-plural-rule := unary-grule &
[ SYN [ HEAD noun & [AGR [NUM plur],
		     ANA false ],
	SPR < >,
	COMPS #comps],
  SEM #sem,
 
  NH1  [SYN [HEAD noun & [AGR [NUM plur] ],
	     SPR < [ ] >,
	     COMPS #comps],
	SEM #sem ] ].
:end :instance.


#|  
;;; turn this back on when all of the cn lexical entries are correctly 
;;; marked. CCB
:begin :instance.
bare-mass-noun-rule := unary-grule &
[ SYN [ HEAD noun & [COUNT false,
	             AGR [NUM #num],
		     ANA false ],
	SPR < >,
	COMPS #comps],
  SEM #sem,
 
  NH1  [SYN [HEAD noun & [ COUNT false,
			   AGR [NUM #num] ],
	     SPR < [ ] >,
	     COMPS #comps],
	SEM #sem ] ].
:end :instance.
|#

:begin :instance.
head-filler-rule := birule-headfinal-minusGAP &
[  SYN [ SPR < >,
	 COMPS < >,
	 GAP  [ LIST #rest,
		LAST #last] ],

   NH1 #1 & [ SYN [ GAP <! !> ] ],
   H [ SYN [ HEAD verb & [ FORM fin ],
		      SPR < >,
		      COMPS < >,
		      GAP [ LIST *cons* & < #1 . #rest>,
			    LAST *null* & #last ] ],
       SEM [MODE prop ] ] ].
:end :instance.



:begin :instance.
noun-coordination-rule := trirule-nonheaded &
 [ SYN [ HEAD noun & [ AGR non-3sing & [ NUM plur ],
		       CASE #case ],
	 SPR #spr,
	 COMPS #comps],
   SEM [ INDEX #ref-index ],

   NH1 [ SYN [ HEAD noun & [CASE #case ],
	       SPR #spr,
	       COMPS #comps ],
	 SEM [ INDEX #1 ] ],
   
   NH2 [ SYN [ HEAD conj & [ FORM f_and ] ],
	 SEM [ INDEX #ref-index ] ],

   NH3 [ SYN [ HEAD noun & [CASE #case ],
	       SPR #spr,
	       COMPS #comps ],
	 SEM [ INDEX #2] ] ].
:end :instance:


:begin :instance.
verb-coordination-rule := trirule-nonheaded &
 [ SYN [ HEAD verb & [FORM #form],
	 SPR #spr,
	 COMPS #comps,
	 GAP #gap ],
   SEM [ MODE prop,
	 INDEX #sit-index ],

   NH1 [ SYN [ HEAD verb & [FORM #form],
	       SPR #spr,
	       COMPS #comps,
	       GAP #gap ],
	 SEM [ MODE prop,
	       INDEX #1 ] ],

   NH2 [ SYN [ HEAD conj & [FORM f_and ] ],
	 SEM [ INDEX #sit-index,
	       RESTR <! [SIT #sit-index] !> ] ],
   
   NH3 [ SYN [ HEAD verb & [FORM #form],
	       SPR #spr,
	       COMPS #comps,
	       GAP #gap ],
	 SEM [ MODE prop,
	       INDEX #2 ] ] ].
:end :instance.


