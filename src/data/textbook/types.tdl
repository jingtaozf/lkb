;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; SYNTACTIC THEORY by Sag and Wasow -- Textbook Grammar 
;;; implementation by Chris Callison-Burch & Scott Guffey
;;;
;;; types.tdl
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:begin :type.

 
feat-struc :< *top*.

synsem-struc := feat-struc &
[ ORTH *diff-list*,              
  SYN  gram-cat,
  SEM  sem-struc ].


agr-cat := feat-struc &
[ PER per,
  NUM num,
  GEND gend ].


gram-cat := feat-struc &
[ HEAD pos,
  SPR	list-of-synsem-structs,
  COMPS list-of-synsem-structs,
  GAP  *diff-list* & [ LIST list-of-synsem-structs ] ].


pos := feat-struc &
[ FORM form-cat,
  PRED boolean,
  ANA boolean ].


sem-struc := feat-struc &
[ MODE  mode-cat,
  INDEX index,
  RESTR list-of-predications ].


predication := feat-struc &
[ RELN reln,
  SIT  sit-index ].


index :< feat-struc.
   ref-index :< index.
   sit-index :< index. 
   null-index :< index.




;;; <<<---- PARTS OF SPEECH ---->>>

verb := pos &
 [ AUX boolean,
   INV boolean,
   NEG boolean,
   ANA false].

;;; Added "topic" to the heirarchy to restrict what can be topicalized
;;; though the GAP and head-filler rules.  CCB
topic :< pos.

nominal-cat := topic & 
 [ AGR agr-cat,
   COUNT boolean ].

noun := nominal-cat &
 [ CASE case-cat ].

det := nominal-cat &
 [ ANA false ].


comp :< pos.

conj := pos &
 [ ANA false ].

mod-type := *value* &
  [ MOD list-of-synsem-structs ].

adv := topic & mod-type &
 [ ANA false ].

adj := pos & mod-type &
 [ ANA false ].

prep := mod-type & nominal-cat.

;;; CCB - Agreement is really only marked on Nouns and Dets.  I added onto preps
;;; because our current bining theory implementation relys on PPs having AGR.




;;; <<<----- TYPES INHERITING FROM FORM-CAT  ----->>>


*value* :< *top*.                


form-cat :< *value*.
   normal :< form-cat.
   inf    :< form-cat.
   fin    :< form-cat.
   prp    :< form-cat.
   psp    :< form-cat.
   imp    :< form-cat.
   pass   :< form-cat.

   
   f_to   :< form-cat.
   f_about:< form-cat.
   f_around:< form-cat.
   f_on   :< form-cat.
   f_in   :< form-cat.
   f_with :< form-cat.
   f_of   :< form-cat.
   f_for  :< form-cat.
   f_by   :< form-cat.
   f_not  :< form-cat.
   f_and  :< form-cat.
   f_advantage :< form-cat.
   f_tabs :< form-cat.
   f_there :< form-cat.
   f_it :< form-cat.


;;; <<<----- STRUCTURE FOR AGR-CAT  ----->>>



3sing := agr-cat & 
 [ PER 3rd,
   NUM sing ].

non-3sing :< agr-cat.


per :< *value*.
   1st :< per.
   2nd :< per.
   3rd :< per.

num :< *value*.
   sing :< num. 
   plur :< num.

gend :< *value*.
   fem  :< gend.
   masc :< gend.
   neut :< gend.


case-cat :< *value*.
   nom :< case-cat.
   acc :< case-cat.



;;; <<>> ----- CONST-LXM DEFINITIONS  -----

; Right now we have MOD implemented as a list to cover the case where the thing that can be
; modified is "none", which we mark as the empty list.  CCB

prep-lxm := const-lxm &
 [ SYN [ HEAD prep ] ].

pdp-lxm := prep-lxm &
 [ SYN [ HEAD [ ANA false ],
	 SPR < [ ] > ],
   ARG-ST < [ SYN [ HEAD noun ] ],  [ SYN [ HEAD noun & [ ANA false,
				                	  CASE acc ] ] ] > ].

mkp-lxm := prep-lxm &  
 [ SYN [ HEAD [ MOD < >, 
		ANA #ana],
	 SPR < > ],
   SEM [ MODE  #mod,
	 INDEX ref-index & #ind ],
   ARG-ST < [ SYN [ HEAD noun & [ CASE acc, 
				  ANA #ana ] ],
	      SEM [ MODE  #mod, 
		    INDEX #ind ] ] > ].

adv-lxm := const-lxm & modifier-sem &
 [ SYN [ HEAD adv & [ MOD < [ SYN [ HEAD verb,
				    COMPS < > ] ] > ] ], 
   SEM [ MODE prop ],
   ARG-ST < > ].

adj-lxm := const-lxm & modifier-sem & 
   [ SYN [ HEAD adj & [ MOD < [ SYN [ HEAD noun,
				      COMPS < > ] ] > ],
	   COMPS < > ],
     SEM [ MODE ref ] ].

conj-lxm := const-lxm &
 [ SYN [ HEAD conj ],
   SEM [ RESTR <! conj_pred !> ],
   ARG-ST < > ].

det-lxm := const-lxm & 
 [ SYN [ HEAD det ],
   SEM null-sem,
   ARG-ST < > ].

comp-lxm := const-lxm & 
[ SYN [ HEAD comp & [ FORM #form ],
	COMPS < [ SYN [ HEAD verb & [ FORM #form ],
			COMPS < > ],
		  SEM [ MODE prop,
			INDEX sit-index & #2 ] ] > ],
  SEM [ MODE prop,
	INDEX sit-index & #1,
	RESTR <! [SIT #1, ARG #2] !> ] ].



;;; <<>> ----- NOUN-LXM DEFINITIONS  -----


; I've put the empty ARG-ST default constraint on the SPR and COMPS, because
; in this system you need to specifically override the default value.  It's not
; able to do clever infrenece about the Argument Realization Principle.   
; 
; I also added [COUNT +] as a default so I didn't have to type it so much.  CCB

noun-lxm := infl-lxm &
 [ SYN [ HEAD noun & [ FORM /l normal,
 		       AGR [ PER /l 3rd ],
		       ANA /l false,
                       COUNT /l true ],
         SPR /l < >,
         COMPS /l < > ],
   SEM [ MODE  /l ref,
         INDEX  #1,
         RESTR <! noun_pred & [ INSTANCE #1] !>  ] ].

pron-lxm :< noun-lxm.


cn-lxm := noun-lxm & 
 [ SYN [ HEAD [ COUNT #count,
		AGR #agr & [ GEND /l neut ] ],
	 SPR < [ SYN [ HEAD det & [AGR #agr, COUNT #count], 
		          SPR < > ] ] > ] ].

;;; Because of the way that non-3sing is currently set up it can unify with [ PER 3rd, NUM sing], 
;;; it's best to mark 3sing explicitly so that pn-lxms will interact with the verb rules properly.
;;; It's still a problem with cn-lxms.  CCB

pn-lxm := noun-lxm & 
 [ SYN [ HEAD [ AGR 3sing ] ],
   SEM [ INDEX #1,
	 RESTR <! named_pred & [ NAMED #1 ] !> ] ].

; This type allows us to have common nouns without specifiers, with different FORM values, and with
; null semantics.   SMG

#|
dummy-idiom-lxm := const-lxm &
 [ SYN  [ HEAD noun & [ ANA false ] ], 
   SEM  null-sem,
   ARG-ST < > ].
|#


dummy-idiom-lxm := const-lxm &
 [ SYN  [ HEAD noun & [ ANA false ] ], 
   ARG-ST < > ].


;;; <<>> ----- VERB LEXEME TYPES  -----

; There really shouldn't be an ANA value in verbs to begin with, this should be corrected by 
; either sticking it in the type hierarchy for np's/pp's only or switching back to ANA/P-OBJ analysis.

; Do we need CASE nom on the first element of the verb-lxm's ARG-ST, it doesn't seem to matter, why?

; FORM normal has been distributed down inside sub lexemes for verbs to account for verbs which allow
; for dummy subjects and objects.  SMG

;;; Attempting to abrieviate the notation -- CCB
NP := gram-cat &
[ HEAD noun,
  SPR < > ].

N := gram-cat & 
[ HEAD noun,
  SPR < [ ] > ].

VP := gram-cat &
[ HEAD verb,
  SPR < [ ] > ].

V := gram-cat &
[ HEAD verb ].

S := gram-cat &
[ HEAD verb,
  SPR < >,
  COMPS < > ].



verb-lxm := infl-lxm & 
 [ SYN [ HEAD verb & [ INV false, 
		       NEG false, 
		       AUX /l false,
		       ANA false],
	 SPR < [ ] > ],   
   SEM [INDEX #1,
	MODE prop,
	RESTR <! predication & [SIT #1] !> ],
   ARG-ST < [ SYN NP ], ... > ].


; [ SYN [ HEAD noun & [ FORM /l normal,
;   				  CASE nom ],
;	      SPR < >,
;	      COMPS < >  ] ],  ...  > ].

iv-lxm := verb-lxm & iv-sem &
 [ ARG-ST < [ ] > ].

piv-lxm := verb-lxm & piv-sem &
 [ ARG-ST < [ ], [ SYN [ HEAD prep, 
			 SPR < >, 
			 COMPS < > ] ] > ].

ctv-lxm := verb-lxm & ctv-sem & 
 [ ARG-ST < [ ], [ SYN [ HEAD comp,
			 COMPS < > ] ] > ].

tv-lxm := verb-lxm &
 [ ARG-ST < [ ], [SYN [ HEAD noun & [ FORM /l normal, CASE acc ],
 			SPR < >,
 			COMPS < > ] ], ... > ].

stv-lxm := tv-lxm & stv-sem &
[ ARG-ST < [ ], [ ] > ].


dtv-lxm := tv-lxm & dtv-sem &
 [ ARG-ST < [ ],  [ ], [ SYN [ HEAD noun & [CASE acc ],
			       SPR < >,
			       COMPS < > ] ] > ].

ptv-lxm := tv-lxm & ptv-sem &
 [ ARG-ST < [ ],  [ ],  [ SYN [ HEAD prep ] ] > ].


;;; Does FORM need to be specified on srv-lxm (and auxv-lxm)?  CCB

#|
srv-lxm := verb-lxm & srv-sem &
[ ARG-ST < #1 ,  [SYN [HEAD [FORM /l inf],
		       SPR < #1 >] ] > ]. 
|#


srv-lxm := verb-lxm & srv-sem &
[ ARG-ST < #1 ,  [SYN [ SPR < #1 > ] ] > ]. 


scv-lxm := verb-lxm & scv-sem &
[ ARG-ST < [SYN [HEAD [AGR #agr] ],
	    SEM [INDEX #1 ]      ], [SYN [ HEAD comp,
					   SPR < [SYN [HEAD [AGR #agr] ],
						  SEM [INDEX #1 ] ] > ] ] > ].

orv-lxm := verb-lxm & orv-sem &
[ ARG-ST < [ ],  #1,  [SYN [SPR < #1 > ] ] > ].


ocv-lxm := verb-lxm & ocv-sem &
[ ARG-ST < [ ] , [SYN [HEAD noun & [AGR #agr] ],
		  SEM [INDEX #1]              ], [SYN [ HEAD comp,
						  SPR < [SYN [HEAD [AGR #agr] ],
							 SEM [INDEX #1] ] > ] ] > ].

auxv-lxm := srv-lxm &
[ SYN [ HEAD verb & [ AUX true ] ] ].




;;; <<<---- TYPES INHERITING FROM SYNSEM-STRUC/LEXICAL RULE DEFINITIONS ---->>>

; AAC added type for feature introduction condition
;
args-type := *top* &
 [ ARGS *list* ].

lex-item := synsem-struc & args-type &
[ ARG-ST *list* ].

mod_affix :< gram-cat.
  affix := mod_affix.
  no-affix :< mod_affix.
 

phrase :=  synsem-struc & args-type.

word :< lex-item.

lexeme := lex-item &
 [ AFFIX mod_affix,
   ORTH #orth,
   SYN [ GAP <! !> ],
   SEM [ RESTR /l <! !> ],
   ARGS < [ ORTH #orth ] > ].



infl-lxm := lexeme &
 [ ARGS < [ AFFIX affix &
		  [ HEAD #head,
		    SPR #spr,
		    COMPS #comps ] ] >,
   SYN [ HEAD #head,
	 SPR #spr,
	 COMPS #comps ] ].

const-lxm := lexeme &
 [ ARGS < [ AFFIX no-affix ] >].

rule := synsem-struc & args-type &
 [ ARGS *list* ],
 status: root-node.






;;; <<>> ----- MOST BASIC DEFINITIONS FOR TYPE HIERARCHY  -----

boolean :< *value*.
   true  :< boolean.               
   false :< boolean.

*list* :< *top*.

ne-list := *cons* &
 [ FIRST *top*,
   REST *list* ].

list-of-synsem-structs :< *list*.

*null* :< list-of-synsem-structs.

ne-list-of-synsem-structs := list-of-synsem-structs & ne-list &
 [ FIRST synsem-struc,
   REST list-of-synsem-structs ].




; LABEL and META used for labeling nodes in parse trees
; AAC - and they must have their features declared ...

label :=  synsem-struc &
   [ LABEL-NAME symbol ],
    status: label.

phrase-label := label & phrase.

word-label := label & word.

meta := synsem-struc &
  [  META-PREFIX symbol,
     META-SUFFIX symbol ],
    status: meta.









