;;;; Generate training and test data for TnT tagger experiments
;;;; Stuart Shieber
;;;; Tue Jan 29 15:12:26 PST 2002


(in-package :tsdb)



;;;;---------------------------------------------------------------------
;;;; Auxiliary functions

;;; derivation-terminalp
;;; --------------------
;;;
;;; Holds if the derivation deriv is a terminal symbol instance.

(defun derivation-terminalp (deriv)
  (stringp (derivation-root deriv)))

;;; derivation-terminal
;;; -------------------
;;;
;;; Returns the terminal symbol associated with a terminal (leaf) of a
;;; derivation.  If the flag normalize is T, replaces all spaces with
;;; underscores so that the terminal symbol will be readable asa
;;; single symbol.

(defun derivation-terminal (deriv &key (normalize nil))
  (and (derivation-terminalp deriv)
       (let* ((string (derivation-root deriv)))
	 (if normalize
	     (substitute #\_ #\Space string)
	   string))))

;;; derivation-preterminalp
;;; -----------------------
;;;
;;; Holds if deriv is a preterminal derivation, that is, is the
;;; immediate parent of a terminal derivation.

(defun derivation-preterminalp (deriv)
  (and (derivation-unaryp deriv)
       (derivation-terminalp (nth-daughter 0 deriv))))

;;; derivation-preterminal
;;; ----------------------
;;; Returns the preterminal symbol associated with a preterminal
;;; derivation.  This is generated by looking up the type of the
;;; instance in the lexicon.

(defun derivation-preterminal (deriv)
  (and (derivation-preterminalp deriv)
       (type-of-lexical-entry (derivation-root deriv))))

;;; nth-daughter
;;; ------------
;;; Returns the nth daughter subderivation for a derivation.  Like
;;; nth(), indexing is zero-based and it returns nil if no such
;;; daughter exists.

(defun nth-daughter (n deriv)
  (nth n (derivation-daughters deriv)))

;;; derivation-unaryp
;;; -----------------
;;; Holds if deriv has just a single child.

(defun derivation-unaryp (deriv)
  (and (nth-daughter 0 deriv)
       (not (nth-daughter 1 deriv))))

;;; type-of-lexical-entry
;;; ---------------------
;;; Returns the (preterminal) type of a lexical entry by lookup in the
;;; lexicon.  Hard error if no type is available from the lexicon.
;;; Essentials of this function (sans error checking) were provided by
;;; Stephan Oepen.

(defun type-of-lexical-entry (instance)
  (let* ((instance (lkb::get-psort-entry instance))
	 (tdfs (and instance (lkb::lex-or-psort-full-fs instance)))
	 (dag (and tdfs (lkb::tdfs-indef tdfs)))
	 (type (when dag (lkb::type-of-fs dag))))
      (if (null type)
	  (error "Null lexical entry type ~s~%" instance)
	type)))


;;;;---------------------------------------------------------------------
;;;; Derivation processing

;;; tnt-process-deriv
;;; -----------------
;;; Generates tagger data for a single derivation deriv, written to
;;; the specified stream (or standard output if none provided).

(defun tnt-process-deriv (deriv &optional (stream t))
  (cond	((derivation-terminalp deriv) 
	 (error "Terminal without preterminal ~s~%" deriv))
        ((derivation-preterminalp deriv)
         (format 
          stream 
          "~(~20a~c~30a~c~%~)"
          (derivation-terminal (nth-daughter 0 deriv) :normalize t)
          #\tab
          (derivation-preterminal deriv)
          #\tab))
	((inflectional-rule-p deriv)
	 (format 
          stream 
          "~(~20a~c~30a~c~@[~a~]~%~)"
          (derivation-terminal 
           (nth-daughter 0 (nth-daughter 0 deriv))
           :normalize t)
          #\tab
          (derivation-preterminal (nth-daughter 0 deriv))
          #\tab
          (when (inflectional-rule-p deriv) (derivation-root deriv))))
	((derivation-daughters deriv)
	 (mapc (lambda (daughter)
		 (tnt-process-deriv daughter stream))
	       (derivation-daughters deriv)))
	(t (error "Unrecognized derivation form ~s~%" deriv))))

;;; export-trees-for-tnt
;;; --------------------
;;; Generates TnT data for all active derivations for the provided
;;; data (defaulting to *tsdb-data*), restricted by the provided
;;; condition and written to files in the directory provided as path.

(defun export-trees-for-tnt (&optional (data *tsdb-data*)
                             &key (condition *statistics-select-condition*)
                                  path prefix)
  (loop
      with target = (or path 
                        (format nil "/home/tmp/~a" (substitute #\. #\/ data)))
                  
      with items = (analyze data :thorough '(:derivation) 
                            :condition condition)
      for item in items
      for input = (or (get-field :o-input item) (get-field :i-input item))
      for i-id = (get-field :i-id item)
      for parse-id = (get-field :parse-id item)
      for trees = (select '("t-version") '(:integer) "tree" 
                          (format nil "parse-id == ~a" parse-id) 
                          data
                          :sort :parse-id)
      for version = (loop
                        for tree in trees
                        maximize (get-field :t-version tree))
      for active = (let ((foo (select '("result-id") '(:integer) "preference" 
                                      (format 
                                       nil 
                                       "parse-id == ~a && t-version == ~d" 
                                       parse-id version) 
                                      data)))
                     (loop for bar in foo collect (get-field :result-id bar)))
      for results = (get-field :results item)
      initially 
        (unless path
          #+:allegro (excl::delete-directory-and-files target))
        #+:allegro (ignore-errors (mkdir target))
      when (= (length active) 1) do
        (format t 
		"~d: ~d active tree~p (of ~d)~%" 
		i-id (length active) (length active) (length results))

	(with-open-file 
	 (stream (format nil "~a/~@[~a.~]~d" target prefix i-id)
		 :direction :output
		 :if-exists :supersede :if-does-not-exist :create)
	 (format 
	  stream
	  "%% TnT data from LinGO Redwoods (~a by ~a)~%~
           %% ~d active tree~p (of ~d) for item # ~d~%~
           %% ~a~%"
          (current-time) (current-user)
	  (length active) (length active) (length results) i-id input)
	 (loop
             with *package* = (find-package lkb::*lkb-package*)
             for result in results
             for id = (get-field :result-id result)
             for derivation = (when (member id active :test #'eql)
                                (get-field :derivation result))
             when derivation do
               (tnt-process-deriv derivation stream)
               (format stream "~%")))))
